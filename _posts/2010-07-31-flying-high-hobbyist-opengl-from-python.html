---
layout: post
status: publish
published: true
title: 'Flying High: Hobbyist OpenGL from Python'
author:
  display_name: tartley
  login: tartley
  email: tartley@tartley.com
  url: http://tartley.com
author_login: tartley
author_email: tartley@tartley.com
author_url: http://tartley.com
wordpress_id: 1142
wordpress_url: http://tartley.com/?p=1142
date: '2010-07-31 14:58:30 -0500'
date_gmt: '2010-07-31 13:58:30 -0500'
categories:
- Python
- Graphics
- Presentations
- GameDev
tags: []
comments:
- id: 30906
  author: Couchsurfer&acirc;&euro;&trade;s guide to Europython&Acirc;&nbsp;(Teil&Acirc;&nbsp;3)
    | Spielend programmieren Blog
  author_email: ''
  author_url: http://spielendprogrammieren.wordpress.com/2010/07/31/couchsurfer%e2%80%99s-guide-to-europython-teil-3/
  date: '2010-07-31 22:18:10 -0500'
  date_gmt: '2010-07-31 21:18:10 -0500'
  content: "[...] Nat&Atilde;&frac14;rlich waren auch andere Vortr&Atilde;&curren;ge
    sehr gut, z.B. J. Hartely&#8217;s Vortrag &Atilde;&frac14;ber OPEN-GL und Python.
    [...]"
- id: 30915
  author: Eric Pavey
  author_email: warpcat@sbcglobal.net
  author_url: http://www.akeric.com
  date: '2010-08-01 01:22:13 -0500'
  date_gmt: '2010-08-01 00:22:13 -0500'
  content: What a great post.  I have yet to delve into OpenGL via Python (I dabble
    in Pygame though, and have done some OpenGL via Processing), and this sucker is
    going on the top of my reference list.  Thanks for taking your time to share.
- id: 31060
  author: Stu
  author_email: Stu.axon@gmail.com
  author_url: http://Stuartaxon.com
  date: '2010-08-03 01:58:23 -0500'
  date_gmt: '2010-08-03 00:58:23 -0500'
  content: Cool, this could provide the basis for a bunch of 3d primitives, a bit
    like papervision3d provides in the actionscript world.
- id: 31082
  author: 'tartley.com : Flying High: OpenGL from Python, Part 2'
  author_email: ''
  author_url: http://tartley.com/?p=1207
  date: '2010-08-03 10:04:46 -0500'
  date_gmt: '2010-08-03 09:04:46 -0500'
  content: "[...] << Back to part 1 [...]"
- id: 31382
  author: Chris
  author_email: chris@deleonic.com
  author_url: http://hobbygamedev.com/
  date: '2010-08-09 04:21:16 -0500'
  date_gmt: '2010-08-09 03:21:16 -0500'
  content: "Excellent post. Attractive and useful illustrations, helpful diagrams,
    and a good balance between code and explanation (something that I very much struggle
    with!).\r\n\r\nThanks for putting the time and energy into articulating these
    details freely for others :D"
- id: 31749
  author: Anylo
  author_email: anylonen@gmail.com
  author_url: ''
  date: '2010-08-17 08:57:24 -0500'
  date_gmt: '2010-08-17 07:57:24 -0500'
  content: Hi, this is kinda stupid request, but could you add some mention about
    licence into repository (like in README.txt file or even better LICENSE file)?
- id: 31843
  author: tartley
  author_email: tartley@tartley.com
  author_url: http://tartley.com
  date: '2010-08-19 12:58:17 -0500'
  date_gmt: '2010-08-19 11:58:17 -0500'
  content: "Hey Anylo: Not a stupid request at all. Done!\r\n\r\nNew BSD *or* any
    OSI-approved open source license of your choice. Liberal enough for ya?\r\n\r\nI
    only overlooked it because when I started out, I didn't anticipate that the resulting
    code might be useful to release publicly. Thanks for the prod."
- id: 35702
  author: Crosshatch shaders | Learning WebGL
  author_email: ''
  author_url: http://learningwebgl.com/blog/?p=2858
  date: '2010-12-10 14:18:07 -0600'
  date_gmt: '2010-12-10 14:18:07 -0600'
  content: "[...] never got round to posting. Most of the WebGL stuff in my tutorials
    aims at something like realism; this post by my friend and colleague Jonathan
    Hartley persuaded me that there&#8217;s much more to creating [...]"
- id: 38946
  author: max
  author_email: maxmetallika@gmail.com
  author_url: http://praveenmax.wordpress.com
  date: '2011-02-18 15:59:46 -0600'
  date_gmt: '2011-02-18 15:59:46 -0600'
  content: Very nice post.Could you tell me which is better and easy for opengl programming
    in python?Is it pyopengl or pyglet.I am into 3d graphics.Thank you!
- id: 39046
  author: tartley
  author_email: tartley@tartley.com
  author_url: http://tartley.com
  date: '2011-02-21 12:15:29 -0600'
  date_gmt: '2011-02-21 12:15:29 -0600'
  content: "@max: \r\nThanks for the comment!\r\n\r\nYou want to get started using
    pyglet. This contains everything you need: opening a window, using mouse or keyboard,
    drawing 2D sprites or 3D geometry, and playing sounds, etc.\r\n\r\nIf you use
    a lot of the OpenGL API directly (all the glXXXX functions) then you might want
    to start using PyOpenGL as well, just because it provides a friendlier Python
    interface to the gl C functions."
- id: 39058
  author: max
  author_email: maxmetallika@gmail.com
  author_url: http://praveenmax.wordpress.com
  date: '2011-02-21 18:03:38 -0600'
  date_gmt: '2011-02-21 18:03:38 -0600'
  content: "@tartley:thx for the reply..btw,which one is better in terms of performance
    and documentation and protability.I am basically from jogl bg and so i can do
    well with both .but sice jogl has poor docs,i am making this switch..thx...gave
    an fb req 2 u"
- id: 39106
  author: tartley
  author_email: tartley@tartley.com
  author_url: http://tartley.com
  date: '2011-02-22 13:09:44 -0600'
  date_gmt: '2011-02-22 13:09:44 -0600'
  content: "Hey Max,\r\n\r\nPyOpenGL focusses on providing Python bindings for the
    OpenGL API. Because of this, it doesn't need much documentation apart from the
    standard OpenGL docs. It has a few helper functions to wrap operations like compiling
    shaders, and being able to use OpenGL contexts produced by various GUI / windowing
    libraries. These extra functions are well documented, including a brilliant shader
    tutorial. Essentially though, it focusses mostly on just providing the OpenGL
    functions for you to use from Python.\r\n\r\nPyglet is more rounded, but it is
    not intended to provide OpenGL bindings - instea, it provides many classes and
    functions for all sorts of game-related development, including windowing, mouse,
    keyboard, sprites, sounds. These are very well documented. Pyglet only exposes
    OpenGL bindings incidentally, since the authors of Pyglet needed to access OpenGL
    for themselves. These bindings are a bit inconvenient to use, but are faster than
    the PyOpenGL bindings.\r\n\r\nBoth PyOpenGL and Pyglet work on Windows, Linux
    and Mac.\r\n\r\nI would recommend starting out with just Pyglet - Get a window
    open, draw some objects in an event loop using the pyglet Sprite or Batch classes.
    You can then move on to using OpenGl function calls directly from Pyglet's bindings
    if you need to. If you end up doing a lot of this, then you can easily import
    PyOpenGL and start using its OpenGL bindings instead. Then, later, on, when you
    come to optimise for performance, you can take the half-dozen OpenGL calls that
    lie within your innermost render loop, and convert them back to pyglet for speed.\r\n\r\nSwitching
    between Pyglet and PyOpenGL is usually simply a matter of importing one or the
    other - they are often a drop-in replacement for one another.\r\n\r\nThis allows
    you to write your program using PyOpenGL's convenient bindings, but replace just
    the performance-critical 5% with pyglet's faster but more fiddly-to-use bindings."
---
<p><em>This is a transcript-from-memory (what I wish I'd said) of the talk I just gave at <a href="http://www.europython.eu/">EuroPython</a> 2010, for which I owe a debt of gratitude to Richard Jones for his last-minute moral support while wrestling with projectors and refresh rates; and to the whole team of hard-working volunteers, especially John Pinner &amp; Richard Taylor, who gave so much time and effort to make EuroPython in the UK brilliant once again.</em></p>
<p><em>The demonstrated </em><em>code </em><em>is available via Mercurial, from <a href="http://code.google.com/p/flyinghigh-opengl-from-python">http://code.google.com/p/flyinghigh-opengl-from-python</a></em></p>
<hr />With this talk I want to give an overview of creating 3D graphics in OpenGL from Python. Instead of covering topics already covered by a thousand OpenGL tutorials, I want to shift attention towards some ideas of how to generate the input to your renderer - how to algorithmically create geometry. I'll show that with just a paltry few hundred lines of relatively simple code, you can generate some interestingly chunky shapes - virtual sculptures, if you will. Since this talk has the word <em>hobbyist</em> in the title, I want to emphasise how easy this is, and I want to have some fun with the pretty pictures.</p>
<p>Out of interest, how many people here are already expert OpenGL users <em>(a few hands hesitantly go up, then some think about it and go down again</em>) err, I mean how many have already used OpenGL to do anything at all <em>(about half the people raise their hand</em>.) Alright, well, I want you all to leave here enthused to go generate your own images or animations or games.</p>
<h2><strong>Inspirations</strong></h2>
<p>As the field of computer graphics advances, there's an understandable tendency for more photorealism, This is laudable, but I also feel that the effort expended on achieving this technical goal is often undertaken without considering whether photorealism is the best aesthetic choice for a particular project.</p>
<p>In the past, games and other applications adopted particular visual styles out of technical necessity. As is often the case, these restrictions resulted in a diverse blossoming of creative ideas, producing an enormous set of distinctive visual styles and experiences.</p>
<p>[caption id="attachment_1148" align="alignnone" width="640" caption="Non-photo-realistic Quake"]<img class="size-full wp-image-1148" title="Non-photo-realistic Quake" src="http://tartley.com/wp-content/uploads/2010/07/nprquake.jpg" alt="Non-photo-realistic Quake" width="640" height="480" />[/caption]</p>
<p>Crucially, the most successful and memorable examples of these were projects that found ways to work in harmony with the restrictions of the medium, rather than attempting to gloss over them.</p>
<p>[caption id="attachment_1150" align="alignnone" width="640" caption="Rez HD"]<img class="size-full wp-image-1150" title="Rez HD" src="http://tartley.com/wp-content/uploads/2010/07/RezHDA.jpg" alt="Rez HD" width="640" height="359" />[/caption]</p>
<p>Advances in computing power and technique provide modern games and applications with a far wider range of options in how to present themselves visually, and yet the greater proportion of them seem content with a conventional and unimaginative 'near-photorealistic' appearance. This disappoints me, because I feel that projects that opt for a more highly stylised look, when appropriately chosen, can create a vastly more striking and memorable artistic experiences. This is true in movies and all kinds of art.</p>
<p>[caption id="attachment_1153" align="alignnone" width="640" caption="Waking Life"]<img class="size-full wp-image-1153" title="Waking Life" src="http://tartley.com/wp-content/uploads/2010/07/wakinglife1.jpg" alt="Waking Life" width="640" height="386" />[/caption]</p>
<p>As an amateur graphics programmer, I don't have large resources nor much experience to throw at the problem, so my options and my abilities are limited. But, like a good artist, I believe it should still be possible to create things that are both strikingly beautiful and highly functional, either by working with the restrictions of the medium, or by finding creative ways to exploit or extend them.</p>
<p>[caption id="attachment_1151" align="alignnone" width="640" caption="Love"]<img class="size-full wp-image-1151" title="Love" src="http://tartley.com/wp-content/uploads/2010/07/love.jpg" alt="Love" width="640" height="274" />[/caption]</p>
<p>In particular, the kind of minimal, clean-lined aesthetic that amateur OpenGL programs take on by default are useful for their crisp precision, as charting and visualisation tools. But above that, I love them for their stark minimalism, their clean lines and homogeneous fields of colour.</p>
<p>[caption id="attachment_1147" align="alignnone" width="640" caption="Tron Legacy"]<img class="size-full wp-image-1147" title="Tron Legacy" src="http://tartley.com/wp-content/uploads/2010/07/tron.jpg" alt="Tron Legacy" width="640" height="264" />[/caption]</p>
<p>I wish more professional game developers had an incentive to aim for less conventional aesthetics - whether they be deliberately retro, or else striking out in some new direction of their own. It's that brave minority of projects which do this which form my inspiration.</p>
<h2><strong>Starting Point</strong></h2>
<p>I'm assuming we already have a minimal OpenGL application, that:</p>
<ul>
<li>Opens a window</li>
<li>Provides an OpenGL context for us to render to</li>
<li>Sets appropriate 3D projection matrix</li>
<li>Sets the initial modelview matrix state based on the position and orientation of a 'camera' object</li>
<li>Calls our empty 'draw' function once per monitor refresh.</li>
</ul>
<p>This results in a blank screen, at 60fps. Here's a screenshot, so you can see exactly what it's doing:</p>
<p>[caption id="attachment_1156" align="alignnone" width="840" caption="A blank screen"]<a href="http://tartley.com/wp-content/uploads/2010/07/blank1.png"><img class="size-large wp-image-1156  " title="A blank screen" src="http://tartley.com/wp-content/uploads/2010/07/blank1-1024x640.png" alt="A blank screen" width="840" height="525" /></a>[/caption]</p>
<p>I'm using pyglet &amp; PyOpenGL for this, but this isn't important. Any framework that provides the above abilities, such as PyGame, along with bindings to OpenGL, will be just fine. Whichever framework you use, this minimal application might take on the order of about 150 lines of code, and is covered in countless tutorials all over the web.</p>
<p>From here on in I plan to show (or at least describe) pretty much all of the code that I add on top of this minimal OpenGL loop.</p>
<h2><strong>Goal</strong></h2>
<p>To begin with, I'm going to lead you as quickly as I can through a Shape class, that model 3D shapes, in a way useful for the creation of geometry, and then a Glyph class that converts these geometries into arrays for OpenGL. Finally these arrays get passed into a Render class, which simply calls glDrawElements to render them.</p>
<p>[caption id="attachment_1158" align="alignnone" width="492" caption="Our Goal"]<a href="http://tartley.com/wp-content/uploads/2010/07/fun-stuff.png"><img class="size-full wp-image-1158 " title="Our Goal" src="http://tartley.com/wp-content/uploads/2010/07/fun-stuff.png" alt="Our Goal" width="492" height="246" /></a>[/caption]</p>
<p>Once the above infrastructure is in place, we can have some fun generating interesting shapes to make pretty pictures with. The conventional way to provide geometry to your OpenGL code is by  loading your data from files. Today though, I want to stick with generating  geometry from code, to see where that leads.</p>
<h2><strong>Modelling Polyhedra</strong></h2>
<p>A polyhedron is a 3D shape with flat faces and straight edges. We can model coloured polyhedra using a simple Shape class:</p>
<pre lang="python">
Vec3 = namedtuple('Vec3', 'x y z')
Color = namedtuple('Color', 'r g b a')

class Shape(object):

    def __init__(self, vertices, faces, face_colors):
        # list of Vec3s
       &nbsp;self.vertices = vertices

        # list of faces, each face is a list of indices into 'vertices'
        self.faces = faces

        # List of colors, one per face
        self.face_colors = face_colors
</pre>
<p>An instance of this class, for example, might represent a yellow cube, or a tetrahedron with green and black faces, or any other coloured polyhedron we can imagine.</p>
<p>To demonstrate how classes Shape, Glyph and Render hang together, let's examine an even simpler example, a yellow triangle joined to a red square:</p>
<p>[caption id="attachment_1159" align="alignnone" width="300" caption="Red Triangle &amp; Yellow Square"]<img class="size-full wp-image-1159 " title="Red Triangle &amp; Yellow Square" src="http://tartley.com/wp-content/uploads/2010/07/triangle-square.png" alt="Red Triangle &amp; Yellow Square" width="300" height="265" />[/caption]</p>
<p>You can see this geometry features five vertices (v0 to v4), which are used by the two faces. This might be represented by an instance of Shape:</p>
<pre lang="python">
v0 = Vec3( 1,  1, 0)
v1 = Vec3( 1, -1, 0)
v2 = Vec3(-1, -1, 0)
v3 = Vec3(-1,  1, 0)
v4 = Vec3( 1,&nbsp; 0, 2)

red = Color(255, 0, 0, 255)
yellow = Color(255, 255, 0, 255)

shape = Shape(
    vertices=[v0, v1, v2, v3, v4],
    faces=[
        [2, 3, 4],&nbsp;&nbsp;&nbsp; # f0, triangle
       &nbsp;[0, 1, 2, 3], # f1, square
    ],
   &nbsp;face_colors=[red, yellow],
)
</pre>
<p>The integers in the 'faces' member are indices into the vertices list. So the triangular face, for example, is formed by linking vertices 2, 3 and 4.</p>
<h2><strong>Step 1. Creating a Ctypes Vertex array</strong></h2>
<p>In order to render our Shape, we need to convert it to some ctypes arrays that OpenGL will eat:</p>
<ul>
<li>glvertices - an array of GLfloats (three for each vertex)</li>
<li>glindices - an array of GLubytes (one for each index of each face)</li>
<li>glcolors - an array of GLubytes (four for each vertex)</li>
</ul>
<p>To generate glvertices, we need to dereference the indices in Shape.faces, to produce a new list of vertices, rearranged into the order they are going to be drawn:</p>
<p>[caption id="attachment_1164" align="alignnone" width="457" caption="Step 1. Dereference indices"]<a href="http://tartley.com/wp-content/uploads/2010/07/dereference-indices.png"><img class="size-full wp-image-1164 " title="Step 1. Dereference indices" src="http://tartley.com/wp-content/uploads/2010/07/dereference-indices.png" alt="Step 1. Dereference indices" width="457" height="316" /></a>[/caption]</p>
<p>The most visible aspect of this change is that the vertices are re-ordered, such that the indices now simply read '0, 1, 2, 3, 4, 5...'. However that isn't actually necessary. The important part of this transformation is that vertices which are re-used are now duplicated in the vertex list. For example v0 now occurs twice. As a result of this vertex duplication, one the two instances of '0' in the faces lists now instead reads '3' (referencing the new second copy of v0).</p>
<p>This duplication of vertices is required, because when v0 is used for the first time, it is as part of the red triangle, and when it is used the second time it is as part of the yellow square. The color of the vertex changes from one occurrence to the next. All the attributes of a vertex (position, color, texture co-ords, normals, etc) are treated as an atomic unit, so whenever any attribute changes, as the color is changing here, the vertex position needs to be redundantly specified again, so as to create a new unique vertex with its own unique attribute values. Even if the color of v0 in our example was identical for each use, we will see later that other vertex attributes such as surface normals will still differ. Don't sweat trying to eliminate these redundancies, they are necessary, unless every single attribute of the re-used vertex (including surface normals) are identical.</p>
<p>The code in Glyph.get_glverts() performs this dereferencing step:</p>
<pre lang="python">
class Glyph(object):

    def get_glverts(self, shape, num_glverts):
       &nbsp;glverts = chain.from_iterable(
           &nbsp;shape.vertices[index]
           &nbsp;for face in shape.faces
           &nbsp;for index in face
       &nbsp;)
       &nbsp;ArrayType = GLfloat * (num_glverts * 3)
       &nbsp;return ArrayType(*glverts)
</pre>
<p>This uses a generator to produce the vertices in the order that we need them. 'ArrayType' shows the standard idiom to create a ctypes array - we take the datatype of the array elements, in this case GLfloat since our vertex positions consist of three floats, and multiply it by the required length of the array. This yields a new array type. The final return statement instantiates this array type using the data supplied by the glverts generator.</p>
<h2><strong>Step 2. Creating Ctypes Index Arrays</strong></h2>
<p>The second job Glyph has to do is create a ctypes indices array, which is derived from the Shape's faces. In doing this, it has to break the Shape's faces down into individual triangles.</p>
<p>[caption id="attachment_1165" align="alignnone" width="577" caption="Step 2. Tessellate indices"]<a href="http://tartley.com/wp-content/uploads/2010/07/tessellate-indices.png"><img class="size-full wp-image-1165 " title="Step 2. Tessellate indices" src="http://tartley.com/wp-content/uploads/2010/07/tessellate-indices.png" alt="Step 2. Tessellate indices" width="577" height="316" /></a>[/caption]</p>
<p>The vertex list is unchanged by this step, and the first face - the triangle - is also unchanged. The second face, the square, has been broken into two triangles.</p>
<p>There are well-known algorithms for breaking an arbitrary polygon down into individual triangles. Using the utility functions found in the GLU library, this can be done in about 150 lines of Python. But in the interests of keeping it simple, I decided to restrict our code to just handling convex faces. Tessellating these faces can be done using a considerably simpler algorithm:</p>
<pre lang="python">
def tessellate(face):
   &nbsp;'''
   &nbsp;Break the given face into triangles.
   &nbsp;e.g. [0, 1, 2, 3, 4] ->
   &nbsp;[[0, 1, 2], [0, 2, 3], [0, 3, 4]]
   &nbsp;Does not work on concave faces.
   &nbsp;'''
   &nbsp;return (
   &nbsp;    [face[0], face[i], face[i + 1]]
      &nbsp; for i in xrange(1, len(face) - 1)
   &nbsp;)
</pre>
<p>We again use a generator, to simply join up the face's first vertex with all the other vertices, like this:</p>
<p>[caption id="attachment_1166" align="alignnone" width="446" caption="Tessellation of convex faces"]<a href="http://tartley.com/wp-content/uploads/2010/07/tessellation.png"><img class="size-full wp-image-1166 " title="Tessellation of convex faces" src="http://tartley.com/wp-content/uploads/2010/07/tessellation.png" alt="Tessellation of convex faces" width="446" height="197" /></a>[/caption]</p>
<p>Now we have our tessellate function, Glyph can now create the glindices array in much the same way as it generated the glvertices. I wasn't smart enough to write this as a generator first time around, I presume it would require more than one generator to do it (anyone?), so I'm needlessly creating an in-memory copy of the sequence, but it turns out I need to take its length right afterwards anyway, so what the heck:</p>
<pre lang="python">
class Glyph(object):

    def get_glindices(self, faces):
       &nbsp;glindices = []
       &nbsp;face_offset = 0
       &nbsp;for face in faces:
           &nbsp;indices = xrange(face_offset, face_offset + len(face))
            glindices.extend(chain(*tessellate(indices)))
            face_offset += len(face)
        ArrayType = GLubyte * len(glindices)
        return ArrayType(glindices)
</pre>
<p>This is more complex than get_glvertices because it is performing both of the transformations described in steps 1 and 2. But it's still pretty straightforward. Note that the type of the index array will have change from GLubytes to GLushorts (or GLuints) if the number of vertices rises above 256 (or 65,536.)</p>
<h2><strong>Step 3. Creating Ctypes Color Arrays</strong></h2>
<p>Finally, we need an array of vertex colors. This is the simplest of the lot, generated by repeating the face_color for each face, once per vertex:</p>
<pre lang="python">
class Glyph(object):

    def get_glcolors(self, faces, face_colors, num_glvertices):
       &nbsp;glcolors = chain.from_iterable(
           &nbsp;repeat(color, len(face))
           &nbsp;for face, color in izip(faces, face_colors)
       &nbsp;)
       &nbsp;ArrayType = GLubyte * (num_glvertices * 4)
       &nbsp;return ArrayType(chain(*glcolors))
</pre>
<h2><strong>First Light</strong></h2>
<p>It's might seem like a teensy bit of a slog to get here, but it hasn't been more than sixty lines of code, and now we're in a position to pass our ctypes arrays into OpenGL's drawElements. This happens in our Render.draw() method:</p>
<pre lang="python">
class Render(object):

    def draw(self, world):
        for item in world:
            glVertexPointer(3, GL_FLOAT, 0, item.glyph.glvertices)
           &nbsp;glColorPointer(4, GL_UNSIGNED_BYTE, 0, item.glyph.glcolors)

            # TODO: handle the item's position and orientation

           &nbsp;glDrawElements(
               &nbsp;GL_TRIANGLES,
               &nbsp;len(item.glyph.glindices),
               &nbsp;GL_UNSIGNED_BYTE,
               &nbsp;item.glyph.glindices
           &nbsp;)
</pre>
<p>This is canonical OpenGL render code, so I'm not going to dissect it, but now we get some actual visible output:</p>
<p>[caption id="attachment_1168" align="alignnone" width="840" caption="Red triangle, yellow square"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-triangle-square.png"><img class="size-full wp-image-1168 " title="Red triangle, yellow square" src="http://tartley.com/wp-content/uploads/2010/07/screen-triangle-square.png" alt="Red triangle, yellow square" width="840" height="525" /></a>[/caption]</p>
<p>Hooray! \o/ We can move our camera position around, and view this 3D object from different angles.</p>
<p>There's a minor wrinkle here that I'm glossing over. I've turned on backface culling, so the triangle and square aren't visible if we view them from the back. For all our future examples I plan on using closed polyhedra, so we won't be able to see the 'backs' of the faces - those will be on the inside of the polyhedron.</p>
<h2><strong>The Fun Stuff</strong></h2>
<p>So now we've got all our infrastructure in place, we can start creating factory functions to churn out some Shapes. Let's start with something straightforward, a tetrahedron (triangle-based pyramid):</p>
<pre lang="python">
def Tetrahedron(edge, face_colors=None):
    size = edge / sqrt(2)/2
   &nbsp;vertices = [
       &nbsp;(+size, +size, +size),
       &nbsp;(-size, -size, +size),
       &nbsp;(-size, +size, -size),
       &nbsp;(+size, -size, -size),
   &nbsp;]
   &nbsp;faces = [ [0, 2, 1], [1, 3, 0], [2, 3, 1], [0, 3, 2] ]
   &nbsp;return Shape(vertices, faces, face_colors)
</pre>
<p>Which produces:</p>
<p>[caption id="attachment_1176" align="alignnone" width="840" caption="A tetrahedron"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-tetrahedron.png"><img class="size-full wp-image-1176" title="A tetrahedron" src="http://tartley.com/wp-content/uploads/2010/07/screen-tetrahedron.png" alt="A tetrahedron" width="840" height="525" /></a>[/caption]</p>
<p>Then a cube factory:</p>
<pre lang="python">
def Cube(edge, face_colors=None):
   &nbsp;e2 = edge / 2
   &nbsp;verts = list(itertools.product(*repeat([-e2, +e2], 3)))
   &nbsp;faces = [
       &nbsp;[0, 1, 3, 2], # left
   &nbsp;    [4, 6, 7, 5], # right
       &nbsp;[7, 3, 1, 5], # front
       &nbsp;[0, 2, 6, 4], # back
       &nbsp;[3, 7, 6, 2], # top
       &nbsp;[1, 0, 4, 5], # bottom
    ]
   &nbsp;return Shape(verts, faces, face_colors)
</pre>
<p>The six faces are quite evident, but the use of <em>itertools.product</em> to produce the list of vertices perhaps deserves a bit of exposition. It's an inspired tip from <a rel="external nofollow" href="http://tzotzioy.blogspot.com/">&Icirc;&curren;&Icirc;&ndash;&Icirc;&copy;&Icirc;&curren;&Icirc;&ndash;&Icirc;&trade;&Icirc;&Yuml;&Icirc;&yen;</a>. Just to spell it out in longhand:</p>
<pre lang="python">
>>> from itertools import repeat, product
>>> list(product(*repeat([-1, +1], 3)))
[(-1, -1, -1), (-1, -1, 1), (-1, 1, -1), (-1, 1, 1),
 (1, -1, -1), (1, -1, 1), (1, 1, -1), (1, 1, 1)]
</pre>
<p>So there are the eight vertices of the cube, and that gets us the following:</p>
<p>[caption id="attachment_1177" align="alignnone" width="840" caption="A cube"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-cube.png"><img class="size-full wp-image-1177 " title="A cube" src="http://tartley.com/wp-content/uploads/2010/07/screen-cube.png" alt="A cube" width="840" height="525" /></a>[/caption]</p>
<p>We can add a few more vertices and faces, to make ourselves a truncated cube:</p>
<p>[caption id="attachment_1187" align="alignnone" width="840" caption="A truncated cube"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-truncated-cube.png"><img class="size-full wp-image-1187" title="A truncated cube" src="http://tartley.com/wp-content/uploads/2010/07/screen-truncated-cube.png" alt="A truncated cube" width="840" height="672" /></a>[/caption]</p>
<p>Once we've got truncated cubes, we might as well add one last face to form the entrance:</p>
<p>[caption id="attachment_1188" align="alignnone" width="840" caption="A truncated cube with entrance"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-space-station.png"><img class="size-full wp-image-1188     " title="A truncated cube with entrance: This is a reference to the space stations from the 1984 computer game 'Elite'." src="http://tartley.com/wp-content/uploads/2010/07/screen-space-station.png" alt="A truncated cube with entrance" width="840" height="672" /></a>[/caption]</p>
<p>There's nothing to stop us adding several of these shapes into the world at once, but since we haven't yet moved any of them away from the origin, they just sit there, embedded within one another:</p>
<p>[caption id="attachment_1196" align="alignnone" width="840" caption="A cube and tetrahedron interpenetrate"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-cube-tetra.png"><img class="size-full wp-image-1196 " title="A cube and tetrahedron interpenetrate" src="http://tartley.com/wp-content/uploads/2010/07/screen-cube-tetra.png" alt="A cube and tetrahedron interpenetrate" width="840" height="525" /></a>[/caption]</p>
<p>[caption id="attachment_1197" align="alignnone" width="840" caption="A truncated cube with two tetrahedrons"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-trunccube-two-tetras.png"><img class="size-full wp-image-1197 " title="A truncated cube with two tetrahedrons" src="http://tartley.com/wp-content/uploads/2010/07/screen-trunccube-two-tetras.png" alt="A truncated cube with two tetrahedrons" width="840" height="525" /></a>[/caption]</p>
<h2><strong>Moving objects around</strong></h2>
<p>In our earlier Render.draw() method, we left a 'TODO' comment in place, to note that we weren't yet handling item positions and orientations. Here's what Render.draw looks like when we fill that code in:</p>
<pre lang="python">
class Render(object):

    def draw(self, world):
        for item in world:
           &nbsp;glVertexPointer(3, GL_FLOAT, 0, item.glyph.glvertices)
          &nbsp; glColorPointer(4, GL_UNSIGNED_BYTE, 0, item.glyph.glcolors)

          &nbsp; glPushMatrix()
           &nbsp;glTranslatef(*item.position)
           &nbsp;glMultMatrixf(item.orientation.matrix)

           &nbsp;glDrawElements(
               &nbsp;GL_TRIANGLES,
               &nbsp;len(item.glyph.glindices),
               &nbsp;GL_UNSIGNED_BYTE,
               &nbsp;item.glyph.glindices
           &nbsp;)
           &nbsp;glPopMatrix()
</pre>
<p>Again, this is very standard OpenGL usage. To set an item's <em>position</em> attribute, I'm going to use a bit of code that I already snuck into the demo without telling you about. It's the code that moves the camera around in space. A simplified version is here, class Orbit, which will return a new position each time it gets called. The locus of this position is an orbit around the origin:</p>
<pre lang="python">
class Orbit(object):
   &nbsp;def __init__(self, distance, speed, phase=None):
        self.distance = distance
        self.speed = speed
        if phase is None:
            phase = random.uniform(0, 2 * pi)
        self.phase = phase

    def __call__(self, time):
        bearing = time * self.speed + self.phase
        x = self.distance * math.sin(bearing)
        z = self.distance * math.cos(bearing)
        return Vec3(x, 0, z)
</pre>
<p>The actual camera uses a slightly longer version I call WobblyOrbit (not shown), which operates in exactly the same way. Any 'mover' class, i.e. one that returns a Vec3 position when called, can be used to move the camera, or any other item, around in space:</p>
<pre lang="python">
class GameItem(object):
    def __init__(self, ** kwargs):
       self.__dict__.update(** kwargs)

world.add( GameItem(
    shape=Cube(1, repeat(red)),
    mover=Orbit(distance=20, speed=4),
) )

# then, in world.update():
for item in self.items:
    if item.mover:
       &nbsp;item.position = item.mover(self.time)
</pre>
<p>Similarly, we can spin items using 'spinner' classes, that tweak an item's orientation as time goes by.</p>
<p>With these all in place, we can now add many Shapes to the world, each moving and rotating independently:</p>
<p>[caption id="attachment_1199" align="alignnone" width="840" caption="Several independently positioned and oriented shapes"]<a href="http://tartley.com/wp-content/uploads/2010/07/screen-several-shapes.png"><img class="size-full wp-image-1199 " title="Several independantly positioned and oriented shapes" src="http://tartley.com/wp-content/uploads/2010/07/screen-several-shapes.png" alt="Several independantly positioned and oriented shapes" width="840" height="525" /></a>[/caption]</p>
<h2><strong>Next week: Composite Shapes...</strong></h2>
<p>This is all great as far as it goes, but it turns out we have a performance problem. Adding more than about 450 shapes at once starts to slow down below 60fps (This is all on my trusty 2005-era Thinkpad T60 laptop.) The bottleneck turns out to be in our Render.draw() loop. Each of those OpenGL functions are from (wrappers around) the OpenGL C library, and calling across the Python / C boundary like this incurs a per-function call overhead. Also, a second looming problem is that creating more interesting shapes is going to become more onerous and error-prone, as we create longer and more complex lists of vertices and faces in our code.</p>
<p>One partial solution to both these problems is to use composite shapes, in which we can compose many copies of our basic shapes into one single, more complex shape. This will allow us to use algorithmic means to produce more fun geometry, and will also help us draw more complex shapes, composed of many simpler shapes, without requiring several separate OpenGL function calls for each of the simple shapes.</p>
<p><a href="http://tartley.com/?p=1207">On to Part 2 >></a></p>
