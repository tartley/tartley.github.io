<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tartley.com (Posts about bash)</title><link>https://tartley.com/</link><description></description><atom:link href="https://www.tartley.com/categories/bash.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:tartley @ the domain tartley dot com"&gt;Jonathan Hartley&lt;/a&gt; </copyright><lastBuildDate>Wed, 08 Dec 2021 22:58:55 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Creating Animated Meme GIFs on the Command-Line</title><link>https://www.tartley.com/posts/creating-animated-meme-gifs-on-the-command-line/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;Got sick of navigating the limitations of various online services to create
animated gif memes, finally figured out how to do it manually. Not a universal
process, just what worked for my situation. (Which is Ubuntu 21.10, "Impish".)&lt;/p&gt;
&lt;p&gt;All of of the ffmpeg invocations could probably be combined into one, but I
show the commands as I used them, as I was figuring each step out.&lt;/p&gt;
&lt;h4&gt;1. Download a video&lt;/h4&gt;
&lt;p&gt;Starting from a video on YouTube:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/6-gJMs6DwuE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;To download this locally,
&lt;a href="https://github.com/ytdl-org/youtube-dl"&gt;install &lt;code&gt;youtube-dl&lt;/code&gt;&lt;/a&gt;,
hit the YouTube &lt;em&gt;share&lt;/em&gt; button to grab the video's encoded URL,
and:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;youtube-dl https://youtu.be/6-gJMs6DwuE -o Ash.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives me an 850KB .mp4 video file.&lt;/p&gt;
&lt;h4&gt;2. Split&lt;/h4&gt;
&lt;p&gt;I only want the final few seconds. To remove the start of the video,
keeping from 6.5 seconds until the end:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ffmpeg -hide_banner -i Ash.mp4 -acodec copy -vcodec libx264 -ss 00:00:06.5 Ash-split.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Args to ffmpeg are position sensitive. Specifying '-ss' (to split the file)
before the input ('-i') can't create the split at an accurate location, since
it has to guess whereabouts in the file the given timestamp will occur. But
putting it after the input (as done here) means it can split accurately on the
given timestamp, since the file has been processed by the time this arg gets
actioned, so accurate timestamp/frame conversion is known, at the cost of
having had to process even the parts of the video that are then discarded.&lt;/p&gt;
&lt;p&gt;Vcodec of libx264 is specified because, according to stackoverflow,
"&lt;a href="https://stackoverflow.com/questions/5651654/ffmpeg-how-to-split-video-efficiently#comment85070704_13289426%22"&gt;scenes in mp4 are broken&lt;/a&gt;, whatever that means,
and specifying "copy", as most people do, gives me an output with no video,
only audio.&lt;/p&gt;
&lt;p&gt;This results in a three second, 217KB .mp4 video file. (the following is just an
image of it).&lt;/p&gt;
&lt;p&gt;&lt;img alt="ash-split.webp" src="https://www.tartley.com/files/2021/ash-split.webp"&gt;&lt;/p&gt;
&lt;h4&gt;3. Crop&lt;/h4&gt;
&lt;p&gt;To crop out the black bars from the top and bottom:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ffmpeg -hide_banner -i Ash-split.mp4 -vf 'crop=iw:365' Ash-split-crop.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we crop it to the input width "iw", and 365 high. In the absense of
any offset ordinates for the crop, ffmpeg defaults to centering them, so this
365 pixels are taken from the middle of the video, which is exactly what we
want.&lt;/p&gt;
&lt;p&gt;This results in a three second, 220KB .mp4 video file.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ash-split-crop.webp" src="https://www.tartley.com/files/2021/ash-split-crop.webp"&gt;&lt;/p&gt;
&lt;h3&gt;4. Resize and convert to gif&lt;/h3&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="s s-Atom"&gt;ffmpeg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;hide_banner&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;Ash&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;split&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;crop&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;mp4&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;vf&lt;/span&gt; &lt;span class="s s-Atom"&gt;'scale=512:-1'&lt;/span&gt; &lt;span class="nv"&gt;Ash&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;split&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;crop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;gif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This results in a grainy-but-passable three second 750KB animated .gif:&lt;/p&gt;
&lt;p&gt;&lt;img alt="ash-split-crop-resize.gif" src="https://www.tartley.com/files/2021/ash-split-crop-resize.gif"&gt;&lt;/p&gt;
&lt;p&gt;The file size can be smaller, if you care, most easily by splitting a shorter
video clip, reducing the frame rate, or reducing the 'scale' in this step.&lt;/p&gt;
&lt;p&gt;Alternately, this could be done using ImageMagik's 'convert', but the result
of that was a very large (10MB) file and played very slowly, and I wasn't
immediately sure how to fix that.&lt;/p&gt;
&lt;h3&gt;5. Add text&lt;/h3&gt;
&lt;p&gt;Using Imagemagik's 'convert':&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;convert \
    Ash-split-crop-resize.gif \
    -coalesce \
    -font impact -pointsize 36 -fill white -stroke black -strokewidth 2 \
    -gravity north -annotate +0+0 'I can''t lie about your chances, but' \
    -gravity south -annotate +0+0 'you have my sympathies' \
    -layers Optimize \
    Ash-split-crop-resize-text.gif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The '-coalesce' option removes all the .gif optimizations, then we apply the
text labels, then the '-layers' option re-applies optimizations. Without this
dance, the text is all twitchy and messy.&lt;/p&gt;
&lt;p&gt;Voilà. Imagine sending it to a co-worker who is taking on a difficult task,
like making changes to that thorny section of the codebase that nobody likes:&lt;/p&gt;
&lt;p&gt;&lt;img alt="ash-split-crop-resize-text.gif" src="https://www.tartley.com/files/2021/ash-split-crop-resize-text.gif"&gt;&lt;/p&gt;&lt;/div&gt;</description><category>bash</category><category>image</category><category>linux</category><category>til</category><category>video</category><guid>https://www.tartley.com/posts/creating-animated-meme-gifs-on-the-command-line/</guid><pubDate>Wed, 08 Dec 2021 21:32:10 GMT</pubDate></item><item><title>Automate Gnome keybindings</title><link>https://www.tartley.com/posts/automate-gnome-keybindings/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;Sick of manual GUI twiddling to fix inconsistent keybindings on various
computers. Solved once and for all, by a new script in my personal
workstation setup bucket:&lt;/p&gt;
&lt;p&gt;Warning: This:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;works great on RHEL,&lt;/li&gt;
&lt;li&gt;doesn't all work on Ubuntu&amp;lt;=17.04, I suspect because Unity has
    it's own set of keybinds that are defined elsewhere.&lt;/li&gt;
&lt;li&gt;works great on Ubuntu 17.10. especially if you go in manually to
    disable the built-in keybinding for Super-V, which displays the
    calendar and notifications window, which shadows my 'toggle window
    maximize vertically'.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="ch"&gt;#!/usr/bin/env bash&lt;/span&gt;

&lt;span class="nv"&gt;kb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'org.gnome.desktop.wm.keybindings'&lt;/span&gt;

&lt;span class="c1"&gt;# Switcher, between windows not apps, uses alt-tab and alt-grave&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; switch-windows &lt;span class="s2"&gt;"['Tab']"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; switch-windows-backward &lt;span class="s2"&gt;"['grave', 'Tab']"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; switch-applications &lt;span class="s2"&gt;"[]"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; switch-applications-backward &lt;span class="s2"&gt;"[]"&lt;/span&gt;

&lt;span class="c1"&gt;# Window maximize toggle, super-up&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; maximize &lt;span class="s2"&gt;"[]"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; toggle-maximized &lt;span class="s2"&gt;"['Up']"&lt;/span&gt;

&lt;span class="c1"&gt;# Window maximize vertically toggle, super-v&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; maximize-vertically &lt;span class="s2"&gt;"['v']"&lt;/span&gt;

&lt;span class="c1"&gt;# run command, super-r&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$kb&lt;/span&gt; panel-run-dialog &lt;span class="s2"&gt;"['r', 'F2']"&lt;/span&gt;


&lt;span class="c1"&gt;# Custom commands&lt;/span&gt;

&lt;span class="nv"&gt;mk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'org.gnome.settings-daemon.plugins.media-keys'&lt;/span&gt;
&lt;span class="nv"&gt;ckb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings'&lt;/span&gt;

gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt; custom-keybindings &lt;span class="s2"&gt;"['&lt;/span&gt;&lt;span class="nv"&gt;$ckb&lt;/span&gt;&lt;span class="s2"&gt;/custom0/', '&lt;/span&gt;&lt;span class="nv"&gt;$ckb&lt;/span&gt;&lt;span class="s2"&gt;/custom1/']"&lt;/span&gt;

gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt;.custom-keybinding:&lt;span class="nv"&gt;$ckb&lt;/span&gt;/custom0/ name &lt;span class="s2"&gt;"screen off"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt;.custom-keybinding:&lt;span class="nv"&gt;$ckb&lt;/span&gt;/custom0/ &lt;span class="nb"&gt;command&lt;/span&gt; &lt;span class="s2"&gt;"screenoff"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt;.custom-keybinding:&lt;span class="nv"&gt;$ckb&lt;/span&gt;/custom0/ binding &lt;span class="s2"&gt;"z"&lt;/span&gt;

gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt;.custom-keybinding:&lt;span class="nv"&gt;$ckb&lt;/span&gt;/custom1/ name &lt;span class="s2"&gt;"terminal"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt;.custom-keybinding:&lt;span class="nv"&gt;$ckb&lt;/span&gt;/custom1/ &lt;span class="nb"&gt;command&lt;/span&gt; &lt;span class="s2"&gt;"terminal"&lt;/span&gt;
gsettings &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;$mk&lt;/span&gt;.custom-keybinding:&lt;span class="nv"&gt;$ckb&lt;/span&gt;/custom1/ binding &lt;span class="s2"&gt;"t"&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Embedded in that is the ultimate solution to my longstanding irk with
Unity and Gnome's default window switcher (alt-tab.) By default it
groups windows of a single application together, requiring some extra
-grave pressing to navigate between windows within an application.&lt;/p&gt;
&lt;p&gt;This not only requires way more effort, but also breaks the expected
behaviour of just tapping alt-tab to go back to the last used window.
Instead it goes back to the last used application, so you can't toggle
between two windows of the same application, eg. two terminals. Absolute
madness.&lt;/p&gt;
&lt;p&gt;The above modifies alt-tab to just cycle through all windows, ungrouped,
which fixes the ability to toggle between last two windows. Also,
alt-grave is provided as an alternative to cycle backwards through the
windows, which is easier to hit than shift-alt-tab.&lt;/p&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>terminal</category><guid>https://www.tartley.com/posts/automate-gnome-keybindings/</guid><pubDate>Thu, 05 Oct 2017 01:06:47 GMT</pubDate></item><item><title>Postscript formatted man pages</title><link>https://www.tartley.com/posts/postscript-formatted-man-pages/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;code&gt;man&lt;/code&gt; and its &lt;code&gt;troff&lt;/code&gt; formatting can be asked to produce postscript
output. Define a Bash function, e.g. in your .bashrc:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;function&lt;/span&gt; psman &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;SLUG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$@&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; tr &lt;span class="s1"&gt;' '&lt;/span&gt; &lt;span class="s1"&gt;'-'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;FNAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/tmp/man-&lt;/span&gt;&lt;span class="nv"&gt;$SLUG&lt;/span&gt;&lt;span class="s2"&gt;.pdf"&lt;/span&gt;
    &lt;span class="nb"&gt;set&lt;/span&gt; -o pipefail
    man -t &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; ps2pdf - &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$FNAME&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
      nohup evince &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$FNAME&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &amp;gt;/dev/null &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;/dev/null
    &lt;span class="nb"&gt;set&lt;/span&gt; +o pipefail
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;(I tried to do this without tempfiles, using process substitution, &lt;a href="https://superuser.com/questions/1243405"&gt;but
failed. Anyone got better
Bash-fu&lt;/a&gt;?)&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;man -t&lt;/code&gt; is the crucial part. It tells &lt;code&gt;man&lt;/code&gt; to produce output in
postscript format, which &lt;code&gt;ps2pdf&lt;/code&gt; can read, and &lt;code&gt;evince&lt;/code&gt; displays the
PDF. We disconnect the evince process using &lt;code&gt;nohup&lt;/code&gt;, so that it lives on
even if we kill the terminal. We `set -o pipefail` so that if `man`
fails, the exit code is preserved as the exit of `man|ps2pdf`, which
causes the `&amp;amp;&amp;amp;` to short-circuit, preventing evince from being run on
an empty pdf document. We restore `+o pipefail` again at the end.&lt;/p&gt;
&lt;p&gt;Then, from the command line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;$ psman tr
&lt;/pre&gt;
&lt;p&gt;produces&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.tartley.com/files/2017/08/pman-tr.png"&gt;&lt;img alt="" src="https://www.tartley.com/files/2017/08/pman-tr.png"&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>terminal</category><guid>https://www.tartley.com/posts/postscript-formatted-man-pages/</guid><pubDate>Wed, 23 Aug 2017 01:34:02 GMT</pubDate></item><item><title>Listen to your phone through your PC speakers</title><link>https://www.tartley.com/posts/listen-to-your-phone-through-your-pc-speakers/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/env bash&lt;/span&gt;

&lt;span class="c1"&gt;# Directs audio input (e.g. mic) to audio output (e.g. speakers),&lt;/span&gt;
&lt;span class="c1"&gt;# then sleeps forever. Stops audio redirection when it is killed.&lt;/span&gt;
&lt;span class="c1"&gt;# So, for example, plug your phone into the PC's mic, run 'listen',&lt;/span&gt;
&lt;span class="c1"&gt;# and listen to phone audio through your computer's speakers.&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;# Requires:&lt;/span&gt;
&lt;span class="c1"&gt;# sudo apt-get install pactl # Ubuntu&lt;/span&gt;

&lt;span class="nb"&gt;set&lt;/span&gt; -e

&lt;span class="nv"&gt;module&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;pactl load-module module-loopback&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; cleanup &lt;span class="o"&gt;{&lt;/span&gt;
    pactl unload-module &lt;span class="nv"&gt;$module&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;trap&lt;/span&gt; cleanup EXIT

sleep infinity
&lt;/code&gt;&lt;/pre&gt;</description><category>bash</category><category>geek</category><guid>https://www.tartley.com/posts/listen-to-your-phone-through-your-pc-speakers/</guid><pubDate>Sun, 15 Mar 2015 15:50:09 GMT</pubDate></item></channel></rss>