<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tartley.com (Posts about command-line)</title><link>https://tartley.com/</link><description></description><atom:link href="https://tartley.com/categories/command-line.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2023 &lt;a href="mailto:tartley @ the domain tartley dot com"&gt;Jonathan Hartley&lt;/a&gt; </copyright><lastBuildDate>Thu, 06 Jul 2023 21:08:45 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Makefiles that are self-documenting, and process all extant files.</title><link>https://tartley.com/posts/til-makefiles-that-are-self-documenting-and-process-all-extant-files/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;h3&gt;Self-documenting Makefiles&lt;/h3&gt;
&lt;p&gt;A trick from years ago, but I copy it around between projects enough that it
deserves calling out. Add a target:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;help&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;## Show this help.&lt;/span&gt;
&lt;span class="c"&gt;    @# Optionally add 'sort' before 'awk'&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;@grep&lt;span class="w"&gt; &lt;/span&gt;-E&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'^[a-zA-Z_\.%-]+:.*?## .*$$'&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;MAKEFILE_LIST&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;awk&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-10s\033[0m %s\n", $$1, $$2}'&lt;/span&gt;
&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Decorate other targets with a descriptive '##' comment, like "&lt;em&gt;Show this help&lt;/em&gt;"
above. Now calling the 'help' target will summarize all the things the Makefile
can do. eg:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$ make help
help       Show this help.
setup      Install required system packages using 'apt install'.
%.pdf      Generate given PDF from corresponding .tex file.
all        Convert all .tex files to PDF.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You might choose to make 'help' the first target in the Makefile, so that it
gets triggered when the user runs &lt;code&gt;make&lt;/code&gt; without arguments.&lt;/p&gt;
&lt;h3&gt;Process all extant files&lt;/h3&gt;
&lt;p&gt;Make's canonical paradigm is that you tell it the name of the file to generate,
and it uses the tree of dependencies specified in the Makefile to figure out
how to build it. Typically you'll use automatic variables like "$&amp;lt;" to represent
the wildcarded source filename:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;%.pdf&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;tex&lt;/span&gt; &lt;span class="c"&gt;## Generate given PDF from corresponding .tex file.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;pdflatex&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The pitfall is that when invoking this, you have to name all the PDF files you
want to generate. If the names are a fixed part of your build, they can be
embedded in the Makefile itself:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;.&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;.&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;.&lt;span class="n"&gt;pdf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But if their names are dynamic, you have to specify them on the command line,
which is a pain:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;make&lt;span class="w"&gt; &lt;/span&gt;one.pdf&lt;span class="w"&gt; &lt;/span&gt;two.pdf&lt;span class="w"&gt; &lt;/span&gt;three.pdf
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is easy enough when &lt;em&gt;re-&lt;/em&gt;generating all the PDFs that already exist:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;make&lt;span class="w"&gt; &lt;/span&gt;*.pdf
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;but is no help when you just have a bunch of .tex files and you just want Make
to build all of them. This is going the opposite way to canonical make usage.
We want to specify the existing source files (&lt;code&gt;*.tex&lt;/code&gt;, in this case), and have
Make build the resulting products.&lt;/p&gt;
&lt;p&gt;To do it, we need our Makefile to enumerate the existing source files:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;TEX_FILES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;wildcard&lt;span class="w"&gt; &lt;/span&gt;*.tex&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using the 'wildcard' function here behaves better than a bare wildcard
expansion, e.g. it produces no output when there are no matches, rather than
outputting the unmatched wildcard expression.&lt;/p&gt;
&lt;p&gt;Then use a substitution to generate the list of .pdf filenames:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;all&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;TEX_FILES:%.tex&lt;span class="o"&gt;=&lt;/span&gt;%.pdf&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now &lt;code&gt;make all&lt;/code&gt; will generate one .pdf file for each extant .tex file, regardless of
whether the corresponding .pdf files already exist or not.&lt;/p&gt;</description><category>command-line</category><category>make</category><category>til</category><guid>https://tartley.com/posts/til-makefiles-that-are-self-documenting-and-process-all-extant-files/</guid><pubDate>Thu, 06 Jul 2023 16:50:16 GMT</pubDate></item><item><title>Download audio from YouTube</title><link>https://tartley.com/posts/download-audio-from-youtube/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;p&gt;For the sort of weirdos who still host their own music files, but aren't
preciously audiophile about it. Aaaaand also I'm wording this with the
assumption you're a Linux, command-line and Python nerd.&lt;/p&gt;
&lt;p&gt;Sometimes it's a video which is explicitly Creative Commons. Other times, it's
a friend's otherwise unpublished non-commercial thing. Or maybe it's a massive
commercial product from a famously litigious corporate behemoth, but you've
already bought the soundtrack and you just really &lt;em&gt;really&lt;/em&gt; wish you had a
version which had the exact same sound effects or dialog or arrangement that
you or your child has grown to love from obsessive movie re-watches.&lt;/p&gt;
&lt;p&gt;I've got ya.&lt;/p&gt;
&lt;h3&gt;One-off setup:&lt;/h3&gt;
&lt;p&gt;Install &lt;a href="https://ffmpeg.org/"&gt;&lt;em&gt;ffmpeg&lt;/em&gt;&lt;/a&gt;, a venerable open-source command-line
video/audio conversion tool.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;ffmpeg
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, install &lt;a href="https://pypa.github.io/pipx/"&gt;&lt;em&gt;pipx&lt;/em&gt;&lt;/a&gt;, a tool to install
commmand-line tools that are distributed as Python packages:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;python3&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;pip&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;--user&lt;span class="w"&gt; &lt;/span&gt;pipx
python3&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;pipx&lt;span class="w"&gt; &lt;/span&gt;ensurepath
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, use pipx to install the &lt;a href="https://youtube-dl.org/"&gt;&lt;em&gt;youtube-dl&lt;/em&gt;&lt;/a&gt;, an
oft-sued but never vanquished tool to download YouTube videos. (We're using
the Python package because the apt package is too old to work):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;pipx&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;youtube-dl
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Goal fulfillment&lt;/h3&gt;
&lt;p&gt;Here, download your precious audio:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;youtube-dl&lt;span class="w"&gt; &lt;/span&gt;-x&lt;span class="w"&gt; &lt;/span&gt;--audio-format&lt;span class="o"&gt;=&lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;URL
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URL&lt;/code&gt; is the encoded version of the video URL (i.e. like "youtu.be/XXX"),
  obtained by hitting the 'share' button on the YouTube page.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x&lt;/code&gt; requests just the audio part, with no video.&lt;/li&gt;
&lt;li&gt;While &lt;code&gt;--audio-format=best&lt;/code&gt; is ostensibly the default setting, meaning
  YouTube decides which format to send, using &lt;code&gt;-x&lt;/code&gt; seems to fail if we don't
  specify this explicitly. Alternatively, you can explicitly request "aac",
  "flac", "mp3", "m4a", "opus", "vorbis", or "wav". As I understand it, YouTube
  will only send the requested format if the uploader provided it. If they
  didn't then we get whatever YouTube provides and then convert it locally
  using ffmpeg. So you sometimes won't be getting the benefit of those lossless
  formats.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But mp3 works well enough for &lt;a href="https://www.youtube.com/watch?v=VSJWvzLuGz8"&gt;my&lt;/a&gt;
&lt;a href="https://www.youtube.com/watch?v=ENVIoR2f-Qgh"&gt;needs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Alternatively, for playlists:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;youtube-dl&lt;span class="w"&gt; &lt;/span&gt;-x&lt;span class="w"&gt; &lt;/span&gt;--audio-format&lt;span class="o"&gt;=&lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;--yes-playlist&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;URL
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--yes-playlist&lt;/code&gt; / &lt;code&gt;--no-playlist&lt;/code&gt; chooses which to download if the URL you
  provide is both a playlist and a video.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; ignores errors, so one bad track in the playlist doesn't stop the whole
  thing.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;My previous inferior way&lt;/h3&gt;
&lt;p&gt;This method is worse because it downloads the whole video file before
extracting audio locally, and the download gets throttled by YouTube in
some way, which of late is very slow indeed, i.e. substantially slower
than watching the video.&lt;/p&gt;
&lt;p&gt;Download the video from YouTube:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;youtube-dl&lt;span class="w"&gt; &lt;/span&gt;URL
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This results in a webm file. I have no idea what that is, and am relieved
to discover that converting it into an mp3 requires just:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ffmpeg&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;MyVideoFile&lt;span class="w"&gt; &lt;/span&gt;-vn&lt;span class="w"&gt; &lt;/span&gt;MyAudioFile.mp3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where &lt;code&gt;-vn&lt;/code&gt; disables video in the output.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;Changelog&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;2023/02/14: Wide-ranging rewrite of prose to enliven, enlink, and clarify.&lt;/li&gt;
&lt;li&gt;2023/02/14: Swapped use of &lt;a href="https://github.com/mitsuhiko/pipsi/"&gt;&lt;em&gt;pipsi&lt;/em&gt;&lt;/a&gt;
  tool, last released 2015, for &lt;em&gt;pipx&lt;/em&gt;, which is more useful, well-maintained
  and popular.&lt;/li&gt;
&lt;li&gt;2022: Added "Goal fulfillment" section, initially called "The Best Way", and
  deprecated the previous method under "My previous inferior way".&lt;/li&gt;
&lt;/ul&gt;</description><category>command-line</category><category>linux</category><category>music</category><category>til</category><category>youtube</category><guid>https://tartley.com/posts/download-audio-from-youtube/</guid><pubDate>Thu, 13 May 2021 16:18:33 GMT</pubDate></item></channel></rss>