<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tartley.com (Posts about non-fiction)</title><link>https://www.tartley.com/</link><description></description><atom:link href="https://www.tartley.com/categories/non-fiction.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:tartley @ the domain tartley dot com"&gt;Jonathan Hartley&lt;/a&gt; </copyright><lastBuildDate>Mon, 17 May 2021 23:37:03 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Structure of Scientific Revolutions</title><link>https://www.tartley.com/posts/the-structure-of-scientific-revolutions/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;This post rescues content from a series of tweets I wrote in 2018.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;I loved &lt;em&gt;The Structure of Scientfic Revolutions&lt;/em&gt;, a 1962 book by Thomas S.
Kuhn. It was recommended to me as having similar impact to undergraduate
classics like &lt;em&gt;Godel, Escher, Bach&lt;/em&gt;, or &lt;em&gt;The Blind Watchmaker.&lt;/em&gt; I'm going
to just summarize the content here, so: Spoilers.&lt;/p&gt;
&lt;p&gt;It begins by observing that discredited scientific theories, even those
which seem laughable today, such as phrenology, or the Ptolemaic model of the
heavens, were not crackpot theories with shaky evidence. Earnest, hardworking
practitioners refined them using sensible processes, which by the 17th century
were converging on the modern scientific method.&lt;/p&gt;
&lt;p&gt;This process of "normal" science excels at the incremental refinement of
established scientific theories. But in practice, is unable to perform the
revolutionary transitions required to overcome outmoded theories and replace
them with others, no matter how bizarre and wrongheaded the initial theory
looks to us now with hindsight.&lt;/p&gt;
&lt;p&gt;So what is the unarticulated process that is responsible for these
transitions, i.e. how do scientific revolutions happen? We have intuitive
visions of this occurring overnight. An individual experiment yields unexpected
results, contradicting conventional theory, while irrefutably supporting an
alternate theory to take its place. But in practice, this &lt;em&gt;never&lt;/em&gt; happens.&lt;/p&gt;
&lt;p&gt;At first, and often for years or centuries, no discrepancy between theory and
experiment is noticed, because the prevailing theories of the time have a
massive shaping effect on what questions it is valid to ask, what experiments
are deemed useful to do.&lt;/p&gt;
&lt;p&gt;For practitioners to turn their backs on an established theory in such a time
is never productive. They are shunned for turning their backs on science
itself.&lt;/p&gt;
&lt;p&gt;We see this vividly today with homeopaths (my own example, not the book's).
Often, and incorrectly, homeopathy is mocked because the theories sound
ridiculous to one steeped in a conventional understanding of chemistry.
People will jeer at how total dilution can 'obviously' have no effect,
or at the idea of water exhibiting some sort of 'memory'. But such jeering is
as scientifically illiterate as the quacks it contends with. The argument from
personal incredulity has no place in determining scientific truth. No newer
theory makes sense in the light of the more limited, and often contradictory,
paradigm that it eventually replaces. The only useful criteria is to try it
out. &lt;em&gt;Does it actually work?&lt;/em&gt; This is the axis upon which homeopathy should be
judged. (and upon which it has decisively been found wanting.)&lt;/p&gt;
&lt;p&gt;All contradictions to conventional science suffer a similar ignominious
treatment, regardless of how right they might later turn out to be. Before any
revolution of theory can overturn conventional understanding, the stage
must be set, the community prepared.&lt;/p&gt;
&lt;p&gt;The process begins as the incremental advances of "normal" science gradually
increase the scope and precision of accepted theories. Until this point,
measurements in which experiment does not conform to theory are either ignored
as erroneous artifacts, or are dismissed as indicative of some separate,
unknown phenomena. They are never interpreted to mean prevailing theory is
wrong.&lt;/p&gt;
&lt;p&gt;However the growing scope &amp;amp; precision of theory and measurement gradually
uncovers more of these discrepancies, or reveals them in finer detail.
Eventually they become too prominent to ignore, and a kind of phase transition
occurs.&lt;/p&gt;
&lt;p&gt;Eventually, the discrepancies become so prominent and concerning that they
are judged to be a valid area of study in themselves, rather than just annoying
aberrations. Leading practitioners devote themselves to the task. Foundations
of the specialisation that were once accepted without question now come under
scrutiny.&lt;/p&gt;
&lt;p&gt;To partially explain the discrepancies, people introduce many incompatible
variations on current theories. The once unified field divides into cliques,
supporting different theoretical variations. The field, formerly a united mass,
calves into fragments.&lt;/p&gt;
&lt;p&gt;If one of these variations on existing theory manages to explain all
observations, then this gradually gains mindshare, until the whole community
has migrated to this new, incrementally improved theory.&lt;/p&gt;
&lt;p&gt;However, in cases where a truly revolutionary change is required, such
incrementalism is insufficient, and none of the theoretical variations are
fully successful in explaining all observations. The factions' differing
underlying assumptions give them no common ground upon which to arbitrate their
differences, so their debates are irreconcilable. The fragments are melting,
into a churning liquid of disagreement.&lt;/p&gt;
&lt;p&gt;This state is notably similar to the state of a nascent field before any
established scientific theories have taken hold.&lt;/p&gt;
&lt;p&gt;All is chaos, with different groups supporting different ideas, agreeing on
nothing. The field is in turmoil, its practitioners in genuine emotional
distress. Their personal identities are undermined. What does it mean to be a
practitioner when nobody can agree on what the field even is? Is what we do
even &lt;em&gt;science&lt;/em&gt; at all? A crisis has arrived. We are at boiling point.&lt;/p&gt;
&lt;p&gt;Kuhn compares this to individuals in psychological experiments, given cunningly
contradictory sensual stimuli. At first they don't notice anything wrong about
a brief glimpse of a playing card showing a red king of clubs. As the length of
their glimpse expands, and the stimulation becomes more intrusive, the subject
starts to hesitate, and stumble on words. Suddenly it impinges on their
consciousness, and they cry out, distressed, uncertain of even basic facts. "My
God! What did I see? Are clubs always red? What's happening here?"&lt;/p&gt;
&lt;p&gt;Kuhn also compares scientific revolutions to their social and political
counterparts, in a chillingly familiar passage:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Political revolutions aim to change political institutions in ways that
those institutions themselves prohibit. Their success therefore necessitates
the partial relinquishment of one set of institutions in favor of another, and
in the interim society is not fully governed by institutions at all.&lt;/p&gt;
&lt;p&gt;Initially it is crisis alone that attenuates the role of political
institutions [...] In increasing numbers, individuals become increasingly
estranged from political life, and behave more &amp;amp; more eccentrically within
it.&lt;/p&gt;
&lt;p&gt;Then, as the crisis deepens, many individuals commit themselves to [...] some
new institutional framework. At that point, society is divided into competing
camps or parties, one seeking to defend the old institutional constellation,
others seeking to institute some new one.&lt;/p&gt;
&lt;p&gt;Once that polarization has occurred, &lt;em&gt;political recourse fails&lt;/em&gt;. Because
they differ about the political matrix within which political change is to be
achieved and evaluated, and acknowledge no common supra-institutional framework
for adjudication of differences, the parties to a revolutionary conflict must
finally resort to the techniques of mass persuasion, often including force."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At any point, the &lt;em&gt;boldest&lt;/em&gt; practitioners, often those with least invested in
the previous status quo, such as the relatively young, or those entering from
adjacent fields, will introduce strikingly different sets of theories. But only
now that the stage is set, amongst such distressing chaos, is the community
ready to entertain truly revolutionary ideas.&lt;/p&gt;
&lt;p&gt;Occasionally, one of these new ideas will succeed in explaining all the
observations, but in order to do so, it requires incommensurable changes in the
underlying philosophy of the field, from the axiomatic definitions, to the set
of questions that are valid to ask. One can no longer ask, of a spherical
Earth, "What happens if you fall off?"&lt;/p&gt;
&lt;p&gt;Notably, many revolutionary changes are not an unalloyed good. Gains in
explicative power in one area are often balanced by losses elsewhere.&lt;/p&gt;
&lt;p&gt;As in evolution, the new theory is not necessarily more &lt;em&gt;correct&lt;/em&gt;, so much as
it is a better fit for the current circumstances, i.e. providing greater
predictive power in an area that is currently pertinent. Maybe scientific
progress is more obviously useful to society in that area, or instruments are
more capable of making measurements in that area. The two often coincide,
since influences are are unable to detect or manipulate are also unlikely to
be of much direct use to society. So as the social and technological context
evolves, so does the relative fitness of potential competing paradigms.&lt;/p&gt;
&lt;p&gt;Nobody understands this trade-off more deeply than the field's most
invested practitioners, who feel the losses of losing the old model most
keenly, and therefore may resist the new paradigm for the remainder of their
careers. The new paradigm will not achieve total dominance until the field is
populated by a whole new generation.&lt;/p&gt;
&lt;p&gt;I am reminded of the dark priesthood of command-line programmers, although
I note with no little joy that our merry band includes some of the best and
brightest of the next generation (as judged by my own paradigm's criteria.)&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>media</category><category>non-fiction</category><category>politics</category><category>science</category><guid>https://www.tartley.com/posts/the-structure-of-scientific-revolutions/</guid><pubDate>Sun, 14 Jun 2020 14:02:22 GMT</pubDate></item><item><title>This Gaming Life: Travels in Three Cities</title><link>https://www.tartley.com/posts/this-gaming-life-travels-in-three-cities/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="gaminglife" src="https://www.tartley.com/files/2014/02/gaminglife.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Jim Rossignol&lt;/em&gt; (2009)&lt;/p&gt;
&lt;p&gt;A gorgeous insider's look at videogaming culture, by an author who,
after an unfulfilling stint as a financial journalist, has built his
life around games.&lt;/p&gt;
&lt;p&gt;Broken into sections corresponding with the author's experiences in
London, Seoul and Reykjavik, it's thoughtful and manages to sidestep the
patronising oversimplifications of mainstream media's gaming coverage.&lt;/p&gt;
&lt;p&gt;From &lt;em&gt;Tetris&lt;/em&gt; and &lt;em&gt;Elite&lt;/em&gt; to &lt;em&gt;Okami&lt;/em&gt; and &lt;em&gt;Shadow of the Collossus&lt;/em&gt;,
stopping along the way to examine the modding and indie scenes, the
massively multiplayer intricacies of &lt;em&gt;EVE Online&lt;/em&gt;, and the insane
heights of Korean real-time strategy matches. He knows the best &lt;em&gt;Prince
of&lt;/em&gt; &lt;em&gt;Persia&lt;/em&gt; was &lt;em&gt;Sands of Time&lt;/em&gt;, by a country mile. He's one of us. I
felt welcomed to his world. Join us - we'll be on the sofa.&lt;/p&gt;
&lt;p&gt;Rating:&lt;/p&gt;
&lt;p&gt;10/10 if you understand that games have the potential to become the
dominant art form of the 21st century.&lt;/p&gt;
&lt;p&gt;0/10 if it's just for kids, innit?&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>games</category><category>media</category><category>non-fiction</category><guid>https://www.tartley.com/posts/this-gaming-life-travels-in-three-cities/</guid><pubDate>Tue, 04 Feb 2014 02:31:29 GMT</pubDate></item><item><title>Object-Oriented Software Engineering : A Use Case Driven Approach</title><link>https://www.tartley.com/posts/object-oriented-software-engineering-a-use-case-driven-approach/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="object-oriented-sofware-engineering" src="https://www.tartley.com/files/2014/02/object-oriented-sofware-engineering.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Ivar Jacobsen&lt;/em&gt; (1992, 4th revision)&lt;/p&gt;
&lt;p&gt;You might wonder if there's anything left to say about
object-orientation that hasn't already been discussed to death. I was
led to this 1992 book by Uncle Bob's talk "&lt;a href="http://www.youtube.com/watch?v=WpkDN78P884"&gt;Architecture: The Lost
Years&lt;/a&gt;." In it Bob posits
that in the 1990s, just as people like Ivar were completing their
20-year journey of figuring out some fairly optimal ways to do
object-orientation, along came the disruptive influence of the web,
which turned everyone's priorities, methodologies and designs upside
down. In the resulting stampede, some highly practical ideas have been
lost, both in terms of design and process. This has substantially
watered down OO's ability to deliver on its promises of reuse and
maintainability. It has stranded a whole generation of applications with
distorted architectures, inside-out designs, and less maintainable code.&lt;/p&gt;
&lt;p&gt;Aspects of these historical approaches do survive, such as the
prominence Agile gives to use-cases as a way to concretely tie together
requirements, design, testing, and acceptance. But some equally powerful
ideas, such as appropriate ways to manage dependencies within an
application, have seen relatively little use, and are only now being
rediscovered in guises such as the clean and hexagonal architectures.&lt;/p&gt;
&lt;p&gt;Ivar's book can certainly lay claim to being one of the earliest
published sources to lay out these ideas, and he does so with a style
that is convincingly thoughtful. This is the work of an intelligent man,
honed and refined over many years of practice. The omission of modern
testing techniques are the only thing that substantially dates the
content. Otherwise I found it exciting, insightful and revolutionary. It
seems naive to claim that this book describes the One True Architecture
which is applicable to all systems. But it certainly seems very widely
applicable, and has deeply affected my thinking on all projects larger
than a couple of weeks' work.&lt;/p&gt;
&lt;p&gt;The book also discusses software development methodology in an
intriguingly meta way, constructing an object-oriented model of the
process itself. Each software development team or organisation
represents a particular implementation of this model. Parallels with the
execution of software are drawn, with the output of one part of the
process, e.g. design work, having to produce results that conform to the
expectations of the downstream process, such as implementation. In this
way, sections of the process can be removed and replaced by compatible
alternatives, to better suit the application domain and the organisation
within which the project is embedded. These ideas seem less immediately
applicable and actionable. Maybe that's just my personal circumstance.
Perhaps they are more applicable to larger projects, which I avoid these
days.&lt;/p&gt;
&lt;p&gt;Rating:&lt;/p&gt;
&lt;p&gt;10/10 if you're going to enjoy 500 pages of software design principles
and case studies.&lt;/p&gt;
&lt;p&gt;0/10 if you're not.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>media</category><category>non-fiction</category><category>software</category><guid>https://www.tartley.com/posts/object-oriented-software-engineering-a-use-case-driven-approach/</guid><pubDate>Sun, 02 Feb 2014 20:26:43 GMT</pubDate></item><item><title>Domain Driven Design: Tackling Complexity in the Heart of Software</title><link>https://www.tartley.com/posts/domain-driven-design-tackling-complexity-in-the-heart-of-software/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="domaindrivendesign" src="https://www.tartley.com/files/2014/01/domaindrivendesign.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Eric Evans (2004)&lt;/em&gt; &lt;a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215"&gt;on Amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It's a big, dense book -- possibly the most important of the technical
books I've read in a flurry over the last few months, catching up after
recovering a modicum of sanity in our lives after our kid's first year.
I finish it feeling changed, invigorated, and given new direction.&lt;/p&gt;
&lt;p&gt;At its core is a simple idea, which sounds neither new nor revolutionary
on the surface. Software projects, Evans maintains, should work closely
with business experts to create and maintain a domain model. The model
might be expressed as a class diagram of core business concerns, and
should also correspond directly to a body of code modelling these
business entities. This forms a set of core business entities which are
clearly analogous to things like the core enterprise entities of the
hexagonal or clean architectures.&lt;/p&gt;
&lt;p&gt;However it's created, the terminology and notation used in the class
diagram (or it's equivalent) should be well understood by individuals on
both side of the tech/business divide. In the past I think I've made the
mistake of believing that only developers needed to understand it, and
therefore the model only needed to be expressed in code.&lt;/p&gt;
&lt;p&gt;This model should be displayed prominently, referred to continually, and
in a healthy project should very directly correspond to the specialised
language that evolves within the organisation. Where the team's language
doesn't match the model - for example, your business experts' use of
plurals betrays that the cardinality of relationships are modelled
wrongly, then the model - and the underlying code - should be
aggressively refactored to match reality.&lt;/p&gt;
&lt;p&gt;Evans makes a persuasive case that the appropriate management of this
complexity at the heart of your software will be a major influence on
the success of the project. To be fair, this is a viewpoint that I
already believed in, so I was a sucker for all of this. Without an
appropriate approach to these central design concerns, over time
developers will find they are no longer able to understand the code
thoroughly enough to be able to modify or extend it easily, unless they
deliberately or inadvertently use design-breaking hacks like redundancy
or mislocated chunks of code. This forms a vicious cycle of technical
debt accrual, and creates an upper limit on the size or complexity which
can be achieved by any project before productivity begins to slump.
Other metrics like reliability then also suffer.&lt;/p&gt;
&lt;p&gt;To counter this, conquering these central design issues requires a
pro-active and multi-pronged effort. Firstly, the existing design must
be understood by all parties. In order for this to remain true, the
design needs to be kept up to date and be easily understood by new team
members. The code must be kept directly in sync with the model, and kept
understandable - inappropriate dependencies must be ruthlessly pruned.
Simultaneously, the "correct" design must be discovered iteratively,
throughout the life of the project, and this can only be done by
encouraging continual conversations between developers and business
folks to discuss the potential inadequacies of the current design and
possible alternatives.&lt;/p&gt;
&lt;p&gt;When managed correctly, this lends an agility and suppleness to project.
Developers find it easy to integrate subsequent parts of code because
they 'fit naturally' into the existing design, and when the design is
found wanting, it's relatively easy to modify it to incorporate new
concerns.&lt;/p&gt;
&lt;p&gt;There are times when I've struggled to convey the message about how the
resulting trade off works between time spent refactoring versus time
saved over the long term. Evans describes this in an interesting way.
Instead of trying to model team productivity by applying a multiplier to
describe drag caused by technical debt, he simply contrasts the normal
way projects slow down as they become larger and more complex, with a
project that instead &lt;em&gt;speeds up&lt;/em&gt; over time, as developers, unhindered by
a cycle of technical debt, are instead empowered by the creation of
powerful and expressive abstractions, which can then be relatively
easily reconfigured into unanticipated configurations.&lt;/p&gt;
&lt;p&gt;To counter-balance this idealistic hand-waving, the next section dives
right into some specific design practices which embody these ideas.
These are valuable and insightful, stock-in-trade, such as
distinguishing between entity and value types. But many of the ideas
were completely new to me, such as the concept of &lt;em&gt;aggregates&lt;/em&gt;, which
define subsets of the domain model which are always atomically retrieved
from (or updated in) a data store.&lt;/p&gt;
&lt;p&gt;In short, I really loved this book. It stretched and inspired me. It's
in a very small set of books I've flagged to re-read in a couple of
years. It's top of my list for 'books to bring in and talk about at
work'.&lt;/p&gt;
&lt;p&gt;Rating:&lt;/p&gt;
&lt;p&gt;10/10 if you're a programmer, or work with programmers.&lt;/p&gt;
&lt;p&gt;0/10 if you're not, or don't.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>media</category><category>non-fiction</category><category>software</category><guid>https://www.tartley.com/posts/domain-driven-design-tackling-complexity-in-the-heart-of-software/</guid><pubDate>Mon, 27 Jan 2014 17:05:53 GMT</pubDate></item><item><title>IronPython in Action</title><link>https://www.tartley.com/posts/ironpython-in-action/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="http://www.amazon.co.uk/IronPython-Action-Michael-Foord/dp/1933988339"&gt;&lt;img alt="ironpython-in-action" src="https://www.tartley.com/files/2009/07/ironpython-in-action.jpg" title="ironpython-in-action"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Michael Foord and Christian Muirhead&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Disclaimer: I'm friends with both the authors and was sent a freebie
review copy by the publisher, so I'm bound to be breathlessly gushing in
this review. Fortunately, that's easy to do, because the book really is
great. (Except for Christian's chapters... &lt;em&gt;Joke!&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;Having spent some years working with .NET, and with a series of
intriguing personal experiments in Python under my belt, I originally
approached IronPython some years ago with a modicum of trepidation. I
feared that the weld between the two would be intrusively visible,
forming distracting differences from regular Python. I feared for the
execution environment, the data types, and perhaps even the syntax
itself.&lt;/p&gt;
&lt;p&gt;Experience with IronPython showed these worries were needless. I have
found IronPython to be a remarkably pleasant marriage - the same elegant
language we know and love, given first-class status in the .NET runtime.
Gifted with seamless interoperability with other .NET languages, the
dowry from such an alliance turns out to be all the .NET libraries in
the world, including the substantial and highly capable .NET standard
libraries themselves.&lt;/p&gt;
&lt;p&gt;IronPython is, to some extent, a niche implementation of a niche
language. However, its position seems to potentially be one of
importance and strength. Not only does it allow Python programmers to
use .NET libraries - and does so admirably, but it also allows the
existing legions of .NET programmers to be introduced to the joys of
Python. They will fall in love with it, and will be able to introduce it
into their workplaces in a way that is politically acceptable. After
all, it is now simply another .NET language. Since .NET is orders of
magnitude more popular than Python, this could turn out to be an
important source of future Python adoption.&lt;/p&gt;
&lt;p&gt;This book is aimed to satisfy programmers coming from both the Python
and the .NET worlds, and in this it seems to succeed. It starts with
quick overviews of concepts from each: 30 pages about Python as a
language, and 17 pages about .NET as an environment (data types, events,
delegates, Windows Forms, etc) - just enough to get everyone up to speed
regardless of background, but without being so verbose as to turn anyone
off with a surfeit of material they are already familiar with. Despite
being brief, these sections are packed with detail and very pragmatic,
focusing on real-world use such as inheriting from existing .NET types,
and solving some common problems like creating Windows Forms
applications from IronPython.&lt;/p&gt;
&lt;p&gt;This style of practical and dense informative content is continued
throughout. Straight after the opening sections, we dive right in with
another rapid-fire chapter, demonstrating common IronPython techniques
by writing a non-trivial application. Woven around this ongoing example,
the chapter discusses many immediately important topics, including duck
typing, Python protocols, MVC, using Windows Forms to build a GUI, tab
pages, dialogs, menus, toolbars, images, saving text files, .NET
Streams, text file encodings, Python exceptions and lambda functions.
These diverse topics are covered rapidly but thoroughly, giving the
reader enough information about each to be able to use them together
from IronPython to create a useful project.&lt;/p&gt;
&lt;p&gt;Having covered these foundations, the book then moves on to address some
specific areas in more detail. The following chapter headings give you
some idea of the topics which are explored in depth:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;First-class functions in action with XML&lt;/em&gt; - demonstrates pragmatic
    use of functions as first-class objects, and higher-order functions
    (functions that take other functions as arguments and return
    modified versions.) and of course decorators. These are shown in
    use, appropriately paired up with the .NET XmlWriter and XmlReader
    classes, demonstrating event driven parsing of XML.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Properties, dialogs and Visual Studio&lt;/em&gt; - Python properties, .NET
    dialogs, and using IronPython in Visual Studio. This sounds like a
    straightforward chapter, but as you might guess, the book gets deep
    into the topics and is jammed full of information. By the end of the
    chapter you'll have added to the example application to create
    document observers, used BinaryFormatter to serialise objects, and
    touched on Python's pickle equivalent.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Agile Testing: where dynamic typing shines&lt;/em&gt; - From the unittest
    module and creating tests, through mock objects, listeners, monkey
    patching, dependency injection and functional testing. This is a
    dense chapter in a dense book, touching along the way on Python
    attribute lookup rules, bound and unbound methods, asynchronous
    execution for functional testing. My only criticism is that it's
    clearly hard for developers to 'get' testing until they have
    hands-on experience of it, so this single-chapter, while very
    thorough in explaining &lt;em&gt;how&lt;/em&gt; to test, has an ambitious remit, and
    doesn't have enough space to explain much of &lt;em&gt;why&lt;/em&gt; we test. I guess
    this is partially my own bias shining through here - I regard
    testing as quite literally the most important thing to happen in
    computer science since the invention of the compiler, and would
    encourage anyone interested to go and read as much as they can about
    it.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Metaprogramming, protocols and more&lt;/em&gt; - More Python protocols,
    dynamic attribute access, and metaclasses. The sorts of things that
    in a static language would be deep black magic, or else completely
    impossible, but here they are just the &lt;em&gt;right&lt;/em&gt; sort of crazy. Read,
    enjoy, and &lt;em&gt;unlearn&lt;/em&gt;. We see how to create a profiling decorator,
    that modifies the functions you pass to it, wrapping them in
    stopwatch timing calls. We also learn about some of the more
    advanced integration of IronPython with the .NET CLR, including
    static compilation of IronPython code into assemblies, and one of
    the very few additions to Python syntax that IronPython has been
    obliged to provide - the typing of .NET arrays and generics. You'll
    never need to use generics yourself (in Python, everything is a
    generic), and you'll never want to go back to typed containers if
    you can avoid it. However, you may need to deal with some from an
    existing C# API, and this is how you do it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Whew! We're only halfway through! The remaining chapters are equally
detailed, but I'm going to start skimming through them somewhat. They
cover the interactions of IronPython with more advanced .NET topics such
as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Windows Presentation Foundation (WPF) and IronPython&lt;/em&gt; - WPF is
    the DirectX user interface library that is a successor to Windows
    Forms. This includes XAML, an XML dialect for describing user
    interfaces, decoupling their implementation from application logic.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Windows System Administration with IronPython&lt;/em&gt; - using IronPython
    as a scripting language for sysadmin automation tasks, from the
    simple, such as copying files, to the complex, such as Windows
    Management Instrumentation (WMI), administration of remote machines,
    and a substantial discussion on the uses of PowerShell with
    IronPython.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;IronPython and&lt;/em&gt; &lt;em&gt;ASP.NET&lt;/em&gt; - building a web-based front end to the
    sample application developed earlier. Reusable controls.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Databases and Web Services&lt;/em&gt; - using ADO.NET to work with databases,
    and using SOAP and REST.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Silverlight: IronPython in the browser&lt;/em&gt; - creating Silverlight
    applications, and accessing the browser DOM from them.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Extending IronPython with C#/.NET&lt;/em&gt; - all about creating C# class
    libraries for use in IronPython, calling unmanaged code from
    IronPython, and creating interfaces on your C# classes to provide
    dynamic, Pythonic behaviour. It also includes dynamic compilation of
    assemblies at runtime, which opens the door to advanced
    code-generation techniques.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Embedding the IronPython Engine&lt;/em&gt; - many developers might want to
    provide IronPython as a scripting language within their own
    application, and this chapter shows you how.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Alright, that's it! There are appendices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;A whirlwind tour of C#&lt;/em&gt; - in case anyone wants more guidance while
    looking at some of the C# code or concepts that are discussed
    throughout the book.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Python magic methods&lt;/em&gt; - a description of &lt;em&gt;all&lt;/em&gt; the Python magic
    double-underscore methods, which is a fabulous resource, one which l
    haven't seen collected anywhere else, and have been referring back
    to ever since I read the book.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So there you have it. If you haven't inferred already, I learned
absolutely &lt;em&gt;heaps&lt;/em&gt; from this book, even though it's about a language and
environment I've been using every day for years. I think I can say
without any equivocation that this is the best IronPython book &lt;em&gt;in the
world&lt;/em&gt;. If you're a .NET person who is curious about Python (and believe
me, &lt;a href="http://xkcd.com/353/"&gt;you&lt;/a&gt;
&lt;a href="http://www.paulgraham.com/avg.html"&gt;should&lt;/a&gt;
&lt;a href="http://www.python.org/about/success/esr/"&gt;be&lt;/a&gt;), or if you're a Python
person who fancies .NET - maybe for DirectX or Silverlight or any number
of other wonderful things, then you should absolutely go directly to the
&lt;a href="http://www.ironpythoninaction.com/"&gt;IronPython in Action book website&lt;/a&gt;
right this second and buy it.&lt;/p&gt;
&lt;p&gt;What are you still doing here?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Good catch Carl, I forgot the all-important rating!&lt;/p&gt;
&lt;p&gt;10/10 if you already use, or are curious about using, IronPython - then
you need this book.&lt;/p&gt;
&lt;p&gt;0/10 if dynamic languages make you break out in hives, or if .NET makes
you think of Darth Vader, then you shouldn't touch this book with a
barge pole.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>media</category><category>non-fiction</category><category>python</category><category>software</category><guid>https://www.tartley.com/posts/ironpython-in-action/</guid><pubDate>Sat, 18 Jul 2009 17:03:31 GMT</pubDate></item><item><title>Opengl Shading Language</title><link>https://www.tartley.com/posts/opengl-shading-language/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="http://www.amazon.co.uk/Opengl-Shading-Language-Randi-Rost/dp/0321334892"&gt;&lt;img alt="OpenGL Shading Language cover" src="https://www.tartley.com/files/2009/05/opengl-shading-language.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Randi J. Rost.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I've had a passing interest in computer graphics for years, but had
avoided the technology of &lt;em&gt;shaders&lt;/em&gt; these last few years, thinking that
they were just another layer of complexity which I didn't need to embark
upon while I was still getting to grips with the standard OpenGL API.&lt;/p&gt;
&lt;p&gt;With hindsight, I was wrong. I was recently cajoled into getting on
board after talking to &lt;a href="http://blog.vrplumber.com/"&gt;Mike Fletcher&lt;/a&gt;
(creator of &lt;a href="http://pyopengl.sourceforge.net/"&gt;PyOpenGL&lt;/a&gt;) after his talk
at PyCon, and now I feel as if I should have read this book years ago.
Shaders solve many of the problems I've been happily messing with for
ages, in ways that are easier to implement, more powerful, and more
performant.&lt;/p&gt;
&lt;p&gt;I &lt;a href="https://www.tartley.com/opengl-programming-guide-6th-ed"&gt;whined about the Red Book&lt;/a&gt;, but this
"Orange" OpenGL Shading Language book is brill - just what I needed.
Incisive without being overly terse, practical, and once it got into the
chapters about applications of multidimensional Perlin noise it got me
all hot'n'bothered about computer graphics again. Yay my inner geek!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; I started this book fascinated by using vertex shaders to
transform geometry on the fly, with little interest in the superficial
fragment shaders used to decorate the rendered surfaces with pretty
images or lighting effects. Since finishing it, this has reversed: I've
become obsessed with noise and Fourier transforms and all the
paraphernalia of fragment shaders, imagining relatively simple fragment
shader that could, I believe, provide a surface with infinite levels of
detail. I dreamed about my old university 'Signals &amp;amp; Systems' type
lectures. Uncanny.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update2:&lt;/strong&gt; Ohdear. Once I started trying to write anything more than
the most trivial of my own shaders, I ran into an unexpected problem. My
shaders just wouldn't link. I couldn't figure out why. The book was no
help. &lt;em&gt;Google&lt;/em&gt; was no help. The error messages &lt;em&gt;certainly&lt;/em&gt; weren't any
help (thanks ATI.) Eventually I realised that the 'built-in' noise
functions which are part of the OpenGL shader language are simply not
implemented by the vast majority of graphics card manufacturers - you
have to roll your own. Which is not a major deal-breaker, but what
&lt;em&gt;is&lt;/em&gt; disappointing is that the OpenGL Shader Language book makes
absolutely no mention of this in any of the chapters plural in which it
lovingly describes the built-in noise functions, along with their
characteristics and uses. Perhaps I spoke too soon when praising the
book. Maybe it is another case of idealistic OpenGL theory that has
something of a disconnect with real world development. Maybe the book
was written before this situation came to pass - regardless, it's no
bloody use to me.&lt;/p&gt;
&lt;p&gt;Rating (oh, how I love my new rating system. Check this one out:)&lt;/p&gt;
&lt;p&gt;10/10 if you want to learn &lt;em&gt;the theory of&lt;/em&gt; how to use the OpenGL shader
language.&lt;/p&gt;
&lt;p&gt;0/10 if you don't.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>graphics</category><category>media</category><category>non-fiction</category><category>software</category><guid>https://www.tartley.com/posts/opengl-shading-language/</guid><pubDate>Tue, 12 May 2009 03:19:26 GMT</pubDate></item><item><title>Envisioning Information</title><link>https://www.tartley.com/posts/envisioning-information/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="Envisioning Information cover" src="https://www.tartley.com/files/2009/04/envisioning_information.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Edward R. Tufte&lt;/em&gt; (1990)&lt;/p&gt;
&lt;p&gt;In much the same vein as Tufte's &lt;em&gt;The Visual Display of Quantitative
Information&lt;/em&gt;, and displaying the same calibre of deeply incisive
common-sense that cuts to the heart of all that's right and wrong about
the art and science of 'information design' - graphic design's more
pragmatic nephew.&lt;/p&gt;
&lt;p&gt;If you love beauty in highly functional graphics, from maps and
diagrams, charts and graphs, tables and typography, then this is for
you.&lt;/p&gt;
&lt;p&gt;Rating:&lt;/p&gt;
&lt;p&gt;10/10 If bad diagrams make you cringe, and good ones make you laugh out
loud.&lt;/p&gt;
&lt;p&gt;0/10 If you only care about beauty, but not about usefulness. Or if you
don't have eyes.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>graphics</category><category>media</category><category>non-fiction</category><guid>https://www.tartley.com/posts/envisioning-information/</guid><pubDate>Tue, 14 Apr 2009 18:07:07 GMT</pubDate></item><item><title>Remix</title><link>https://www.tartley.com/posts/remix/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="remix" src="https://www.tartley.com/files/2009/04/remix.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Lawrence Lessig&lt;/em&gt;, 2008.&lt;/p&gt;
&lt;p&gt;Is creating a mix CD for a friend an act of creativity, or a criminal
offence? When you shoot a home video of your child which has a TV on in
the background, is there really any need for lawsuits? What business do
federal laws have in trying to regulate this sort of activity anyway?&lt;/p&gt;
&lt;p&gt;For those, like me, who view modern copyright law as a morass of
intractable problems, irreconcilable interests, overreaching government
intervention and profoundly unfair restrictions on personal freedoms,
Professor Lessig's words are a welcome infusion of clarity, pragmatism
and respect for all interested parties.&lt;/p&gt;
&lt;p&gt;With an engaging and accessible style, he describes exactly what is
wrong with modern copyright, with clarity and impartiality, and why this
is a deep and pervasive problem that cuts to the heart of all that we
value in human culture. He describes how fixing this would benefit each
of us, from individual consumers and amateur producers, through
professional writers, musicians and copyright holders. Then, in a
surprisingly constructive final section, he outlines five simple changes
to copyright law that would, at a stroke, fix all the major problems,
vastly simplify the situation, eliminate the ambiguity over the legality
of our everyday actions, and all without apparently causing any harm or
loss to any interested party.&lt;/p&gt;
&lt;p&gt;Rating:&lt;/p&gt;
&lt;p&gt;10/10 If you have any interest in the forces that are reshaping our
society and turning industries upside-down within the space of years.&lt;/p&gt;
&lt;p&gt;0/10 If you dislike freedom or free markets, or are a big fan of
overbearing government regulation and monopolies.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>culture</category><category>internet</category><category>law</category><category>media</category><category>non-fiction</category><guid>https://www.tartley.com/posts/remix/</guid><pubDate>Wed, 08 Apr 2009 04:42:58 GMT</pubDate></item><item><title>Beginning Game Development With Python and PyGame</title><link>https://www.tartley.com/posts/beginning-game-development-with-python-and-pygame/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="" src="https://www.tartley.com/files/2009/01/beginning-game-development-with-python-and-pygame.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Will McGugan&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Introduces Python, PyGame and game development ideas from the ground up,
in a really pleasant writing style which is both unintimidating, clear
and covers all the bases. It's definitely a book for beginners though,
walking through high-school topics like bitmaps and vectors and
matrices, but having laid the foundations, it works up to an excellent
hands-on overview of using OpenGL in the final three chapters, including
lighting, textures and fog. It makes all the topics very accessible, and
does an incredible job of putting all the various topics to work
together to form a cohesive and illustrating whole.&lt;/p&gt;
&lt;p&gt;Nothing extremely hardcore is covered though. An 'ants chasing spiders'
state machine is probably the most involved example in here, barring the
latter parts of the OpenGL section, with four-state creatures
beautifully explained and presented. If you're already doing OpenGL or
game development, even as a piss-poor amateur like myself, you likely
already know many of the things between these covers, aside from the
PyGame specifics, which are generally transparent enough to figure out
yourself.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; In the months since I wrote this review, I've found my
thoughts returning to this book time and again, and have come to the
conclusion that I gained more from its extremely clear exposition than I
realised at the time. I'm revising the review scores significantly
upwards to reflect this.&lt;/p&gt;
&lt;p&gt;Rating: 10/10 for beginners. 5/10 for experts. Consider yourself
somewhere between the two.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>gamedev</category><category>media</category><category>non-fiction</category><category>python</category><category>software</category><guid>https://www.tartley.com/posts/beginning-game-development-with-python-and-pygame/</guid><pubDate>Mon, 12 Jan 2009 06:17:54 GMT</pubDate></item><item><title>Expert Python Programming</title><link>https://www.tartley.com/posts/expert-python-programming/</link><dc:creator>Jonathan Hartley</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="http://www.packtpub.com/expert-python-programming/book"&gt;&lt;img alt="expert-python-programming" src="https://www.tartley.com/files/2009/01/expert-python-programming.jpg" title="expert-python-programming"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;by Tarek Ziadé&lt;/em&gt;, 2008. (&lt;a href="http://www.packtpub.com/expert-python-programming/book"&gt;on Packt&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Publisher &lt;a href="http://www.packtpub.com/"&gt;Packt&lt;/a&gt; were nice enough to send me
a copy of this, so I'm completely biased. Fortunately for everyone, I
really liked it. But I have to say that. But I really did!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;. . .&lt;/p&gt;
&lt;p&gt;I've been using &lt;a href="http://python.org/"&gt;Python&lt;/a&gt; for a couple of years now,
but only on a &lt;a href="http://resolversystems.com/"&gt;single project&lt;/a&gt;, so while
there are parts of it that I know very well, there is doubtlessly a lack
of cross-fertilisation in the things I am exposed to. So I was looking
forward to this book.&lt;/p&gt;
&lt;p&gt;Surprisingly, for such a straightforward-sounding title, it is not at
all what I expected.&lt;/p&gt;
&lt;p&gt;What I expected was analyses and illustrations of using Python's more
powerful features: &lt;a href="http://en.wikipedia.org/wiki/Dynamic_programming_language"&gt;dynamic
designs&lt;/a&gt;;
&lt;a href="http://jjinux.blogspot.com/2005/03/python-create-new-class-on-fly.html"&gt;creating classes on the
fly&lt;/a&gt;;
&lt;a href="http://en.wikipedia.org/wiki/Functional_programming"&gt;functional
programming&lt;/a&gt;
styles;
&lt;a href="http://en.wikipedia.org/wiki/Closure_(computer_science)"&gt;closures&lt;/a&gt; and
&lt;a href="http://en.wikipedia.org/wiki/Metaclasses"&gt;metaclasses&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Sure enough, there is an early couple of chapters devoted to advanced
language features. First up,
&lt;a href="http://docs.python.org/library/stdtypes.html#iterator-types"&gt;iterators&lt;/a&gt;,
and &lt;a href="http://docs.python.org/tutorial/classes.html#generator-expressions"&gt;generator
expressions&lt;/a&gt;,
and then the &lt;a href="http://www.python.org/doc/2.6/reference/expressions.html#yield-expressions"&gt;&lt;code&gt;.send&lt;/code&gt;, &lt;code&gt;.throw&lt;/code&gt; and &lt;code&gt;.close&lt;/code&gt;
methods&lt;/a&gt;
on a
&lt;a href="http://docs.python.org/tutorial/classes.html#generators"&gt;generator&lt;/a&gt;,
which induce the &lt;a href="http://docs.python.org/reference/simple_stmts.html#the-yield-statement"&gt;&lt;code&gt;yield&lt;/code&gt;
statement&lt;/a&gt;
to return values or raise exceptions. This is then used to handily
illustrate &lt;a href="http://en.wikipedia.org/wiki/Coroutine"&gt;coroutines&lt;/a&gt; as a
method of &lt;a href="http://en.wikipedia.org/wiki/Co-operative_multitasking#Cooperative_multitasking.2Ftime-sharing"&gt;co-operative
multi-tasking&lt;/a&gt;
without the calamity involved with getting all
&lt;a href="http://en.wikipedia.org/wiki/Thread_(computer_science)"&gt;multi-threaded&lt;/a&gt;.
It's exactly the sort of feature I'd pondered writing for myself for a
&lt;a href="http://code.google.com/p/sole-scion/"&gt;personal project&lt;/a&gt;, oblivious that
the language provides it out of the box.&lt;/p&gt;
&lt;p&gt;Other low-level topics covered include the indispensable
&lt;a href="http://docs.python.org/library/itertools.html"&gt;&lt;code&gt;itertools&lt;/code&gt;&lt;/a&gt; module,
interesting uses of &lt;a href="http://www.python.org/dev/peps/pep-0318/"&gt;function
decorators&lt;/a&gt;, best practices
for subclassing built-in types, sensible use of &lt;a href="http://users.rcn.com/python/download/Descriptor.htm"&gt;descriptors and
properties&lt;/a&gt;,
understanding &lt;a href="http://www.python.org/download/releases/2.3/mro/"&gt;method resolution
order&lt;/a&gt; and using
&lt;a href="http://docs.python.org/library/functions.html#super"&gt;&lt;code&gt;super&lt;/code&gt;&lt;/a&gt;, the
often-overlooked
&lt;a href="http://docs.python.org/reference/datamodel.html#id3"&gt;&lt;code&gt;slots&lt;/code&gt;&lt;/a&gt;, and
finally &lt;a href="http://en.wikipedia.org/wiki/Metaprogramming"&gt;meta-programming&lt;/a&gt;
and
&lt;a href="http://www.voidspace.org.uk/python/articles/metaclasses.shtml"&gt;metaclasses&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Interestingly, this list has only one item of overlap with my
expectations. Tarek has done a good job of choosing important but
sometimes overlooked topics, and while, inevitably, I was very familiar
with some of the things he talked about, other sections were complete
revelations for me.&lt;/p&gt;
&lt;p&gt;However, this is only chapters 2 and 3! The rest of the book expands in
scope beyond Python the language, to look at the environments and tools
that make up the Python ecosystem. In a way, this sounded less
intriguing to me than the computer-science oriented exploration of
language features that I had expected. But having finished the book, I
now realise that it was exactly what I needed.&lt;/p&gt;
&lt;p&gt;The opening chapter goes through installing Python - a topic which I
didn't think needed discussion. But Tarek goes on to cover using &lt;a href="http://www.mingw.org/"&gt;MinGW
and MSYS&lt;/a&gt; to set up a credible command-line
environment under Windows. I've always used
&lt;a href="http://www.cygwin.com/"&gt;Cygwin&lt;/a&gt; for this in the past, and trying out
MSYS (coupled with the project
&lt;a href="http://sourceforge.net/projects/console/"&gt;Console&lt;/a&gt;) is a breath of
fresh air.&lt;/p&gt;
&lt;p&gt;This cross-platform development environment is then rounded out a little
by installing and using things like
&lt;a href="http://peak.telecommunity.com/DevCenter/setuptools"&gt;setuptools&lt;/a&gt;, and
some thoughtful notes on integrating Python development into editors
like &lt;a href="http://www.vim.org/"&gt;Vim&lt;/a&gt; and
&lt;a href="http://www.gnu.org/software/emacs/"&gt;Emacs&lt;/a&gt;, or an IDE like
&lt;a href="http://www.eclipse.org/"&gt;Eclipse&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The rest of the book covers some of the major tools in the Python world.&lt;/p&gt;
&lt;p&gt;I've never previously been forced to get to grips with
&lt;a href="http://docs.python.org/library/distutils.html"&gt;Distutils&lt;/a&gt;. Applying
lessons from the book to a personal project got me completely up to
speed with using Distutils to create packages, making source and binary
distributions, using
&lt;a href="http://peak.telecommunity.com/DevCenter/PythonEggs"&gt;eggs&lt;/a&gt;, and
distributing dependant packages that together make up an application.
The only thing really missing from this is maybe generating stand-alone
executables using &lt;a href="http://www.py2exe.org/"&gt;py2exe&lt;/a&gt; (for Windows) or
&lt;a href="http://undefined.org/python/py2app.html"&gt;py2app&lt;/a&gt; (for Macs), although
this idea is mentioned in passing.&lt;/p&gt;
&lt;p&gt;The following chapters give competent overviews of a wide variety of
topics:&lt;/p&gt;
&lt;p&gt;8. &lt;a href="http://en.wikipedia.org/wiki/Revision_control"&gt;Version control
systems&lt;/a&gt;: centralised,
illustrated by &lt;a href="http://subversion.tigris.org/"&gt;Subversion&lt;/a&gt;, or
distributed like
&lt;a href="http://www.selenic.com/mercurial/wiki/index.cgi/Mercurial"&gt;Mercurial&lt;/a&gt;.
Continuous integration using &lt;a href="http://buildbot.net/trac"&gt;Buildbot&lt;/a&gt;.
Presumably you will either already know these inside-out or else will
lap them up hungrily.&lt;/p&gt;
&lt;p&gt;9. &lt;a href="http://en.wikipedia.org/wiki/Waterfall_model"&gt;Waterfall&lt;/a&gt;,
&lt;a href="http://en.wikipedia.org/wiki/Spiral_model"&gt;spiral&lt;/a&gt; and
&lt;a href="http://en.wikipedia.org/wiki/Iterative_development"&gt;iterative&lt;/a&gt; project
life cycles. I'm not sure that &lt;em&gt;waterfall&lt;/em&gt; is really used by anyone
except in case studies of 'what not to do', and I'm also not sure how
you could be a developer without being aware of this, but maybe that's
precisely the point: You can't be a developer if you don't do this. This
chapter then covers setting up an instance of
&lt;a href="http://trac.edgewall.org/"&gt;Trac&lt;/a&gt; and using it to manage a project's
deliverables, defects, and milestones.&lt;/p&gt;
&lt;p&gt;10. Documenting a project using
&lt;a href="http://docutils.sourceforge.net/rst.html"&gt;ReStructuredText&lt;/a&gt; and
&lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt;, and including hints on good
technical writing. This caused me to completely revamp the content of my
small personal project's documentation, and as a result it is both much
improved, and shorter to boot. Wins all round.&lt;/p&gt;
&lt;p&gt;11. &lt;a href="http://en.wikipedia.org/wiki/Test_driven_development"&gt;Test-Driven
Development&lt;/a&gt;. This
chapter would be a superb overview of the topic for someone who didn't
know about TDD. Although I use TDD extensively at work, I've never used
&lt;a href="http://somethingaboutorange.com/mrl/projects/nose/"&gt;nose&lt;/a&gt;, fearing that
getting to grips with it might be too intrusive or disruptive. In fact,
it is seamless to begin using it in a small way and slowly extend into
its more advanced features as and when you need them.&lt;/p&gt;
&lt;p&gt;12. Optimisation : General principles (ie. don't) and profiling
techniques. I had never used the
&lt;a href="http://docs.python.org/library/profile.html"&gt;cProfile&lt;/a&gt; module described
here, having just whipped up homespun profilers on-the-spot whenever I
needed them, and it's a valuable addition to my arsenal.&lt;/p&gt;
&lt;p&gt;13. Optimisation : Solutions. &lt;a href="http://en.wikipedia.org/wiki/Big_O_notation"&gt;Big O
notation&lt;/a&gt;. Correct use of
different collection types.
&lt;a href="http://docs.python.org/library/threading.html"&gt;Multi-threading&lt;/a&gt;,
&lt;a href="http://docs.python.org/library/multiprocessing.html#module-multiprocessing"&gt;multi-processing&lt;/a&gt;,
caching. Not much that is tremendously new to me here, but it is
obviously a huge topic to cover in a a single chapter, and it covers the
bases competently.&lt;/p&gt;
&lt;p&gt;14. &lt;a href="http://en.wikipedia.org/wiki/Design_patterns"&gt;Design Patterns&lt;/a&gt;, and
how they apply (or don't) to Python. It has been said that design
patterns, as fundamental and necessary as they are to a software
engineer's mindset, are a symptom a language's lack of
[expressivity]{#query .query}. You shouldn't have to write &lt;a href="http://www.dofactory.com/Patterns/PatternVisitor.aspx#csharp-scroll"&gt;huge gobs of
code&lt;/a&gt;
to express simple conceptual relationships. Although Tarek never
explicitly says this, to some extent it is born out by this chapter.
Trivial (and
&lt;a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/"&gt;much-maligned&lt;/a&gt;)
ideas like the
&lt;a href="http://en.wikipedia.org/wiki/Singleton_pattern"&gt;&lt;em&gt;Singleton&lt;/em&gt;&lt;/a&gt;, after a
page or two of alternate implementations, boil down to simply 'use a
module', i.e. zero lines of code. Slightly more complex patterns such as
&lt;a href="http://en.wikipedia.org/wiki/Visitor_pattern"&gt;&lt;em&gt;Visitor&lt;/em&gt;&lt;/a&gt;, are only a
few lines. It is still useful to discuss and name patterns, but on the
whole reference implementations are so trivial as to be unnecessary,
except perhaps as the most concise and precise method of illustration.&lt;/p&gt;
&lt;p&gt;The book overall, then, is a grab-bag of different topics. Each chapter
could clearly be expanded into one or more whole books. As a result, no
part can be covered in very great depth, but Tarek does an admirable job
of getting the reader up to speed enough in each area that they can be
self-sufficient and direct their own learning from that point.&lt;/p&gt;
&lt;p&gt;As as result of the broad scope of the book it serves as a brilliant
annotated laundry list of 'things the Python developer ought to know'.
While there will doubtlessly be some sections that you are already
deeply familiar with, if you have any interest in discovering your own
deficiencies as a Python programmer, I can highly recommend it.&lt;/p&gt;
&lt;p&gt;Rating: 7.5/10 - Made concrete improvements to the way I work every day.&lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>media</category><category>non-fiction</category><category>python</category><category>software</category><guid>https://www.tartley.com/posts/expert-python-programming/</guid><pubDate>Mon, 12 Jan 2009 04:58:26 GMT</pubDate></item></channel></rss>